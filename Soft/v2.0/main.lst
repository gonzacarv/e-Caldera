CCS PCM C Compiler, Version 4.140, 32554               21-may.-18 19:24

               Filename:   D:\2.Datos\Electronica\Proyectos\Microchip\Proyecto Caldera\Soft\v2.0\main.lst

               ROM used:   4705 words (57%)
                           Largest free fragment is 2048
               RAM used:   36 (10%) at main() level
                           62 (17%) worst case
               Stack:     8 locations

*
0000:  MOVLW  12
0001:  MOVWF  0A
0002:  GOTO   24E
0003:  NOP
.................... /////////////////////////////////////////////////////////////////// 
.................... //    Titulo: Firmware de control de Caldera de calefaccion      // 
.................... //    Autor: Gonzalo Carvallo                                    // 
.................... //    e-mail: gonzacarv@gmail.com    Fecha: Mayo de 2018         // 
.................... /////////////////////////////////////////////////////////////////// 
....................  
.................... #include <16f877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #device ADC=8 
.................... #fuses HS, WDT, NOPROTECT, NOLVP, PUT, BROWNOUT // Opciones de configuración 
.................... #use delay(clock=20000000) //Clock speed HZ = 20MHZ 
*
0090:  MOVLW  4C
0091:  MOVWF  04
0092:  BCF    03.7
0093:  MOVF   00,W
0094:  BTFSC  03.2
0095:  GOTO   0A3
0096:  MOVLW  06
0097:  MOVWF  78
0098:  CLRF   77
0099:  DECFSZ 77,F
009A:  GOTO   099
009B:  DECFSZ 78,F
009C:  GOTO   098
009D:  MOVLW  7B
009E:  MOVWF  77
009F:  DECFSZ 77,F
00A0:  GOTO   09F
00A1:  DECFSZ 00,F
00A2:  GOTO   096
00A3:  RETURN
*
05CA:  MOVLW  03
05CB:  SUBWF  48,F
05CC:  BTFSS  03.0
05CD:  GOTO   5D8
05CE:  MOVLW  48
05CF:  MOVWF  04
05D0:  BCF    03.7
05D1:  MOVF   00,W
05D2:  BTFSC  03.2
05D3:  GOTO   5D8
05D4:  GOTO   5D6
05D5:  GOTO   5D6
05D6:  DECFSZ 00,F
05D7:  GOTO   5D5
05D8:  RETURN
.................... #include <flex_lcd.c> 
.................... // flex_lcd.c  
....................  
.................... // These pins are for the Microchip PicDem2-Plus board,  
.................... // which is what I used to test the driver.  Change these  
.................... // pins to fit your own board.  
....................  
.................... #define LCD_DB4   PIN_D4 
.................... #define LCD_DB5   PIN_C7 
.................... #define LCD_DB6   PIN_C6 
.................... #define LCD_DB7   PIN_C5 
....................  
.................... #define LCD_E     PIN_D5 
.................... #define LCD_RS    PIN_D7 
.................... #define LCD_RW    PIN_D6 
....................  
.................... /* 
....................  
.................... #define LCD_DB4   PIN_G2 
.................... #define LCD_DB5   PIN_J0 
.................... #define LCD_DB6   PIN_G3 
.................... #define LCD_DB7   PIN_J1 
....................  
.................... #define LCD_E     PIN_C4 
.................... #define LCD_RS    PIN_C3 
.................... #define LCD_RW    PIN_C2 
....................  
.................... */ 
....................  
.................... // If you only want a 6-pin interface to your LCD, then  
.................... // connect the R/W pin on the LCD to ground, and comment  
.................... // out the following line.  
....................  
.................... #define USE_LCD_RW   1       
....................  
.................... //========================================  
....................  
.................... #define lcd_type 2        // 0=5x7, 1=5x10, 2=2 lines  
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line  
....................  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................  0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots  
....................  0xc,                    // Display on  
....................  1,                      // Clear display  
....................  6                       // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
.................... // Note:  !! converts an integer expression  
.................... // to a boolean (1 or 0).  
....................  output_bit(LCD_DB4, !!(nibble & 1));  
*
00A4:  BTFSC  53.0
00A5:  GOTO   0A8
00A6:  BCF    08.4
00A7:  GOTO   0A9
00A8:  BSF    08.4
00A9:  BSF    03.5
00AA:  BCF    08.4
....................  output_bit(LCD_DB5, !!(nibble & 2));   
00AB:  BCF    03.5
00AC:  BTFSC  53.1
00AD:  GOTO   0B0
00AE:  BCF    07.7
00AF:  GOTO   0B1
00B0:  BSF    07.7
00B1:  BCF    20.7
00B2:  MOVF   20,W
00B3:  BSF    03.5
00B4:  MOVWF  07
....................  output_bit(LCD_DB6, !!(nibble & 4));     
00B5:  BCF    03.5
00B6:  BTFSC  53.2
00B7:  GOTO   0BA
00B8:  BCF    07.6
00B9:  GOTO   0BB
00BA:  BSF    07.6
00BB:  BCF    20.6
00BC:  MOVF   20,W
00BD:  BSF    03.5
00BE:  MOVWF  07
....................  output_bit(LCD_DB7, !!(nibble & 8));     
00BF:  BCF    03.5
00C0:  BTFSC  53.3
00C1:  GOTO   0C4
00C2:  BCF    07.5
00C3:  GOTO   0C5
00C4:  BSF    07.5
00C5:  BCF    20.5
00C6:  MOVF   20,W
00C7:  BSF    03.5
00C8:  MOVWF  07
....................  
....................  delay_cycles(1);  
00C9:  NOP
....................  output_high(LCD_E);  
00CA:  BCF    08.5
00CB:  BCF    03.5
00CC:  BSF    08.5
....................  delay_us(2);  
00CD:  MOVLW  02
00CE:  MOVWF  77
00CF:  DECFSZ 77,F
00D0:  GOTO   0CF
00D1:  GOTO   0D2
00D2:  NOP
....................  output_low(LCD_E);  
00D3:  BSF    03.5
00D4:  BCF    08.5
00D5:  BCF    03.5
00D6:  BCF    08.5
.................... }  
00D7:  RETURN
....................  
.................... //-----------------------------------  
.................... // This sub-routine is only called by lcd_read_byte().  
.................... // It's not a stand-alone routine.  For example, the  
.................... // R/W signal is set high by lcd_read_byte() before  
.................... // this routine is called.       
....................  
.................... #ifdef USE_LCD_RW  
.................... int8 lcd_read_nibble(void)  
.................... {  
.................... int8 retval;  
.................... // Create bit variables so that we can easily set  
.................... // individual bits in the retval variable.  
.................... #bit retval_0 = retval.0  
.................... #bit retval_1 = retval.1  
.................... #bit retval_2 = retval.2  
.................... #bit retval_3 = retval.3  
....................  
.................... retval = 0;  
00D8:  CLRF   54
....................      
.................... output_high(LCD_E);  
00D9:  BSF    03.5
00DA:  BCF    08.5
00DB:  BCF    03.5
00DC:  BSF    08.5
.................... delay_cycles(1);  
00DD:  NOP
....................  
.................... retval_0 = input(LCD_DB4);  
00DE:  BSF    03.5
00DF:  BSF    08.4
00E0:  BCF    03.5
00E1:  BCF    54.0
00E2:  BTFSC  08.4
00E3:  BSF    54.0
.................... retval_1 = input(LCD_DB5);  
00E4:  BSF    20.7
00E5:  MOVF   20,W
00E6:  BSF    03.5
00E7:  MOVWF  07
00E8:  BCF    03.5
00E9:  BCF    54.1
00EA:  BTFSC  07.7
00EB:  BSF    54.1
.................... retval_2 = input(LCD_DB6);  
00EC:  BSF    20.6
00ED:  MOVF   20,W
00EE:  BSF    03.5
00EF:  MOVWF  07
00F0:  BCF    03.5
00F1:  BCF    54.2
00F2:  BTFSC  07.6
00F3:  BSF    54.2
.................... retval_3 = input(LCD_DB7);  
00F4:  BSF    20.5
00F5:  MOVF   20,W
00F6:  BSF    03.5
00F7:  MOVWF  07
00F8:  BCF    03.5
00F9:  BCF    54.3
00FA:  BTFSC  07.5
00FB:  BSF    54.3
....................    
.................... output_low(LCD_E);  
00FC:  BSF    03.5
00FD:  BCF    08.5
00FE:  BCF    03.5
00FF:  BCF    08.5
....................      
.................... return(retval);     
0100:  MOVF   54,W
0101:  MOVWF  78
.................... }     
0102:  RETURN
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_LCD_RW  
.................... int8 lcd_read_byte(void)  
.................... {  
.................... int8 low;  
.................... int8 high;  
....................  
.................... output_high(LCD_RW);  
*
0107:  BSF    03.5
0108:  BCF    08.6
0109:  BCF    03.5
010A:  BSF    08.6
.................... delay_cycles(1);  
010B:  NOP
....................  
.................... high = lcd_read_nibble();  
010C:  CALL   0D8
010D:  MOVF   78,W
010E:  MOVWF  53
....................  
.................... low = lcd_read_nibble();  
010F:  CALL   0D8
0110:  MOVF   78,W
0111:  MOVWF  52
....................  
.................... return( (high<<4) | low);  
0112:  SWAPF  53,W
0113:  MOVWF  77
0114:  MOVLW  F0
0115:  ANDWF  77,F
0116:  MOVF   77,W
0117:  IORWF  52,W
0118:  MOVWF  78
.................... }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
.................... output_low(LCD_RS);  
*
0103:  BSF    03.5
0104:  BCF    08.7
0105:  BCF    03.5
0106:  BCF    08.7
....................  
.................... #ifdef USE_LCD_RW  
.................... while(bit_test(lcd_read_byte(),7)) ;  
*
0119:  MOVF   78,W
011A:  MOVWF  52
011B:  BTFSC  52.7
011C:  GOTO   107
.................... #else  
.................... delay_us(60);   
.................... #endif  
....................  
.................... if(address)  
011D:  MOVF   50,F
011E:  BTFSC  03.2
011F:  GOTO   125
....................    output_high(LCD_RS);  
0120:  BSF    03.5
0121:  BCF    08.7
0122:  BCF    03.5
0123:  BSF    08.7
.................... else  
0124:  GOTO   129
....................    output_low(LCD_RS);  
0125:  BSF    03.5
0126:  BCF    08.7
0127:  BCF    03.5
0128:  BCF    08.7
....................        
....................  delay_cycles(1);  
0129:  NOP
....................  
.................... #ifdef USE_LCD_RW  
.................... output_low(LCD_RW);  
012A:  BSF    03.5
012B:  BCF    08.6
012C:  BCF    03.5
012D:  BCF    08.6
.................... delay_cycles(1);  
012E:  NOP
.................... #endif  
....................  
.................... output_low(LCD_E);  
012F:  BSF    03.5
0130:  BCF    08.5
0131:  BCF    03.5
0132:  BCF    08.5
....................  
.................... lcd_send_nibble(n >> 4);  
0133:  SWAPF  51,W
0134:  MOVWF  52
0135:  MOVLW  0F
0136:  ANDWF  52,F
0137:  MOVF   52,W
0138:  MOVWF  53
0139:  CALL   0A4
.................... lcd_send_nibble(n & 0xf);  
013A:  MOVF   51,W
013B:  ANDLW  0F
013C:  MOVWF  52
013D:  MOVWF  53
013E:  CALL   0A4
.................... }  
013F:  RETURN
....................  
.................... //----------------------------  
.................... void lcd_init(void)  
.................... {  
.................... int8 i;  
....................  
.................... output_low(LCD_RS);  
*
1011:  BSF    03.5
1012:  BCF    08.7
1013:  BCF    03.5
1014:  BCF    08.7
....................  
.................... #ifdef USE_LCD_RW  
.................... output_low(LCD_RW);  
1015:  BSF    03.5
1016:  BCF    08.6
1017:  BCF    03.5
1018:  BCF    08.6
.................... #endif  
....................  
.................... output_low(LCD_E);  
1019:  BSF    03.5
101A:  BCF    08.5
101B:  BCF    03.5
101C:  BCF    08.5
....................  
.................... delay_ms(15);  
101D:  MOVLW  0F
101E:  MOVWF  4C
101F:  BCF    0A.4
1020:  CALL   090
1021:  BSF    0A.4
....................  
.................... for(i=0 ;i < 3; i++)  
1022:  CLRF   3E
1023:  MOVF   3E,W
1024:  SUBLW  02
1025:  BTFSS  03.0
1026:  GOTO   033
....................    {  
....................     lcd_send_nibble(0x03);  
1027:  MOVLW  03
1028:  MOVWF  53
1029:  BCF    0A.4
102A:  CALL   0A4
102B:  BSF    0A.4
....................     delay_ms(5);  
102C:  MOVLW  05
102D:  MOVWF  4C
102E:  BCF    0A.4
102F:  CALL   090
1030:  BSF    0A.4
....................    }  
1031:  INCF   3E,F
1032:  GOTO   023
....................  
.................... lcd_send_nibble(0x02);  
1033:  MOVLW  02
1034:  MOVWF  53
1035:  BCF    0A.4
1036:  CALL   0A4
1037:  BSF    0A.4
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
1038:  CLRF   3E
1039:  MOVF   3E,W
103A:  SUBLW  03
103B:  BTFSS  03.0
103C:  GOTO   04A
....................    {  
....................     lcd_send_byte(0, LCD_INIT_STRING[i]);  
103D:  MOVF   3E,W
103E:  BCF    0A.4
103F:  CALL   004
1040:  BSF    0A.4
1041:  MOVWF  3F
1042:  CLRF   50
1043:  MOVF   3F,W
1044:  MOVWF  51
1045:  BCF    0A.4
1046:  CALL   103
1047:  BSF    0A.4
....................      
....................     // If the R/W signal is not used, then  
....................     // the busy bit can't be polled.  One of  
....................     // the init commands takes longer than  
....................     // the hard-coded delay of 60 us, so in  
....................     // that case, lets just do a 5 ms delay  
....................     // after all four of them.  
....................     #ifndef USE_LCD_RW  
....................     delay_ms(5);  
....................     #endif  
....................    }  
1048:  INCF   3E,F
1049:  GOTO   039
....................  
.................... }  
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
.................... int8 address;  
....................  
.................... if(y != 1)  
*
01F5:  DECFSZ 4D,W
01F6:  GOTO   1F8
01F7:  GOTO   1FB
....................    address = lcd_line_two;  
01F8:  MOVLW  40
01F9:  MOVWF  4E
.................... else  
01FA:  GOTO   1FC
....................    address=0;  
01FB:  CLRF   4E
....................  
.................... address += x-1;  
01FC:  MOVLW  01
01FD:  SUBWF  4C,W
01FE:  ADDWF  4E,F
.................... lcd_send_byte(0, 0x80 | address);  
01FF:  MOVF   4E,W
0200:  IORLW  80
0201:  MOVWF  4F
0202:  CLRF   50
0203:  MOVF   4F,W
0204:  MOVWF  51
0205:  CALL   103
.................... }  
0206:  RETURN
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................  switch(c)  
....................    {  
0207:  MOVF   4B,W
0208:  XORLW  0C
0209:  BTFSC  03.2
020A:  GOTO   212
020B:  XORLW  06
020C:  BTFSC  03.2
020D:  GOTO   21A
020E:  XORLW  02
020F:  BTFSC  03.2
0210:  GOTO   220
0211:  GOTO   225
....................     case '\f':  
....................       lcd_send_byte(0,1);  
0212:  CLRF   50
0213:  MOVLW  01
0214:  MOVWF  51
0215:  CALL   103
....................       delay_ms(2);  
0216:  MOVLW  02
0217:  MOVWF  4C
0218:  CALL   090
....................       break;  
0219:  GOTO   22A
....................      
....................     case '\n':  
....................        lcd_gotoxy(1,2);  
021A:  MOVLW  01
021B:  MOVWF  4C
021C:  MOVLW  02
021D:  MOVWF  4D
021E:  CALL   1F5
....................        break;  
021F:  GOTO   22A
....................      
....................     case '\b':  
....................        lcd_send_byte(0,0x10);  
0220:  CLRF   50
0221:  MOVLW  10
0222:  MOVWF  51
0223:  CALL   103
....................        break;  
0224:  GOTO   22A
....................      
....................     default:  
....................        lcd_send_byte(1,c);  
0225:  MOVLW  01
0226:  MOVWF  50
0227:  MOVF   4B,W
0228:  MOVWF  51
0229:  CALL   103
....................        break;  
....................    }  
.................... }  
022A:  RETURN
....................  
.................... //------------------------------  
.................... #ifdef USE_LCD_RW  
.................... char lcd_getc(int8 x, int8 y)  
.................... {  
.................... char value;  
....................  
.................... lcd_gotoxy(x,y);  
....................  
.................... // Wait until busy flag is low.  
.................... while(bit_test(lcd_read_byte(),7));   
....................  
.................... output_high(LCD_RS);  
.................... value = lcd_read_byte();  
.................... output_low(lcd_RS);  
....................  
.................... return(value);  
.................... }  
.................... #endif 
....................  
.................... #include <1wire.c> 
.................... // (C) copyright 2003 j.d.sandoz / jds-pic !at! losdos.dyndns.org  
....................  
.................... // released under the GNU GENERAL PUBLIC LICENSE (GPL)  
.................... // refer to http://www.gnu.org/licenses/gpl.txt  
....................  
.................... // This program is free software; you can redistribute it and/or modify  
.................... // it under the terms of the GNU General Public License as published by  
.................... // the Free Software Foundation; either version 2 of the License, or  
.................... // (at your option) any later version.  
....................  
.................... // This program is distributed in the hope that it will be useful,  
.................... // but WITHOUT ANY WARRANTY; without even the implied warranty of  
.................... // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  
.................... // GNU General Public License for more details.  
....................  
.................... // You should have received a copy of the GNU General Public License  
.................... // along with this program; if not, write to the Free Software  
.................... // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA  
....................  
.................... /***********************1Wire Class***********************/  
.................... /*Description: This class handles all communication */  
.................... /* between the processor and the 1wire */  
.................... /* sensors.  
.................... /*********************************************************/  
....................  
.................... /*-------1-wire definitions-------*/  
.................... #define ONE_WIRE_PIN1 PIN_A0  
.................... #define ONE_WIRE_PIN2 PIN_A1 
....................  
.................... /*******************1-wire communication functions********************/  
....................  
.................... /************onewire_reset*************************************************/  
.................... /*This function initiates the 1wire bus */  
.................... /* */  
.................... /*PARAMETERS: */  
.................... /*RETURNS: */  
.................... /*********************************************************************/  
....................  
.................... void onewire1_reset()  // OK if just using a single permanently connected device  
.................... {  
....................  output_low(ONE_WIRE_PIN1);  
*
05D9:  BSF    03.5
05DA:  BCF    05.0
05DB:  BCF    03.5
05DC:  BCF    05.0
....................  delay_us( 500 ); // pull 1-wire low for reset pulse  
05DD:  MOVLW  02
05DE:  MOVWF  47
05DF:  MOVLW  F9
05E0:  MOVWF  48
05E1:  CALL   5CA
05E2:  DECFSZ 47,F
05E3:  GOTO   5DF
....................  output_float(ONE_WIRE_PIN1); // float 1-wire high  
05E4:  BSF    03.5
05E5:  BSF    05.0
....................  delay_us( 500 ); // wait-out remaining initialisation window.  
05E6:  MOVLW  02
05E7:  BCF    03.5
05E8:  MOVWF  47
05E9:  MOVLW  F9
05EA:  MOVWF  48
05EB:  CALL   5CA
05EC:  DECFSZ 47,F
05ED:  GOTO   5E9
....................  output_float(ONE_WIRE_PIN1);  
05EE:  BSF    03.5
05EF:  BSF    05.0
.................... }  
05F0:  BCF    03.5
05F1:  RETURN
.................... void onewire2_reset()  // OK if just using a single permanently connected device  
.................... {  
....................  output_low(ONE_WIRE_PIN2);  
*
07DA:  BSF    03.5
07DB:  BCF    05.1
07DC:  BCF    03.5
07DD:  BCF    05.1
....................  delay_us( 500 ); // pull 1-wire low for reset pulse  
07DE:  MOVLW  02
07DF:  MOVWF  47
07E0:  MOVLW  F9
07E1:  MOVWF  48
07E2:  CALL   5CA
07E3:  DECFSZ 47,F
07E4:  GOTO   7E0
....................  output_float(ONE_WIRE_PIN2); // float 1-wire high  
07E5:  BSF    03.5
07E6:  BSF    05.1
....................  delay_us( 500 ); // wait-out remaining initialisation window.  
07E7:  MOVLW  02
07E8:  BCF    03.5
07E9:  MOVWF  47
07EA:  MOVLW  F9
07EB:  MOVWF  48
07EC:  CALL   5CA
07ED:  DECFSZ 47,F
07EE:  GOTO   7EA
....................  output_float(ONE_WIRE_PIN2);  
07EF:  BSF    03.5
07F0:  BSF    05.1
.................... }  
07F1:  BCF    03.5
07F2:  RETURN
.................... /*********************** onewire_write() ********************************/  
.................... /*This function writes a byte to the sensor.*/  
.................... /* */  
.................... /*Parameters: byte - the byte to be written to the 1-wire */  
.................... /*Returns: */  
.................... /*********************************************************************/  
....................  
.................... void onewire1_write(int data)  
.................... {  
....................  int count;  
....................  
....................  for (count=0; count<8; ++count)  
*
05F2:  CLRF   48
05F3:  MOVF   48,W
05F4:  SUBLW  07
05F5:  BTFSS  03.0
05F6:  GOTO   619
....................  {  
....................   output_low(ONE_WIRE_PIN1);  
05F7:  BSF    03.5
05F8:  BCF    05.0
05F9:  BCF    03.5
05FA:  BCF    05.0
....................   delay_us( 2 ); // pull 1-wire low to initiate write time-slot.  
05FB:  MOVLW  02
05FC:  MOVWF  77
05FD:  DECFSZ 77,F
05FE:  GOTO   5FD
05FF:  GOTO   600
0600:  NOP
....................   output_bit(ONE_WIRE_PIN1, shift_right(&data,1,0)); // set output bit on 1-wire  
0601:  BCF    03.0
0602:  RRF    47,F
0603:  BTFSC  03.0
0604:  GOTO   607
0605:  BCF    05.0
0606:  GOTO   608
0607:  BSF    05.0
0608:  BSF    03.5
0609:  BCF    05.0
....................   delay_us( 60 ); // wait until end of write slot.  
060A:  MOVLW  63
060B:  MOVWF  77
060C:  DECFSZ 77,F
060D:  GOTO   60C
060E:  GOTO   60F
....................   output_float(ONE_WIRE_PIN1); // set 1-wire high again,  
060F:  BSF    05.0
....................   delay_us( 2 ); // for more than 1us minimum.  
0610:  MOVLW  02
0611:  MOVWF  77
0612:  DECFSZ 77,F
0613:  GOTO   612
0614:  GOTO   615
0615:  NOP
....................  }  
0616:  BCF    03.5
0617:  INCF   48,F
0618:  GOTO   5F3
.................... }  
0619:  RETURN
.................... void onewire2_write(int data)  
.................... {  
....................  int count;  
....................  
....................  for (count=0; count<8; ++count)  
*
0C9C:  CLRF   48
0C9D:  MOVF   48,W
0C9E:  SUBLW  07
0C9F:  BTFSS  03.0
0CA0:  GOTO   4C3
....................  {  
....................   output_low(ONE_WIRE_PIN2);  
0CA1:  BSF    03.5
0CA2:  BCF    05.1
0CA3:  BCF    03.5
0CA4:  BCF    05.1
....................   delay_us( 2 ); // pull 1-wire low to initiate write time-slot.  
0CA5:  MOVLW  02
0CA6:  MOVWF  77
0CA7:  DECFSZ 77,F
0CA8:  GOTO   4A7
0CA9:  GOTO   4AA
0CAA:  NOP
....................   output_bit(ONE_WIRE_PIN2, shift_right(&data,1,0)); // set output bit on 1-wire  
0CAB:  BCF    03.0
0CAC:  RRF    47,F
0CAD:  BTFSC  03.0
0CAE:  GOTO   4B1
0CAF:  BCF    05.1
0CB0:  GOTO   4B2
0CB1:  BSF    05.1
0CB2:  BSF    03.5
0CB3:  BCF    05.1
....................   delay_us( 60 ); // wait until end of write slot.  
0CB4:  MOVLW  63
0CB5:  MOVWF  77
0CB6:  DECFSZ 77,F
0CB7:  GOTO   4B6
0CB8:  GOTO   4B9
....................   output_float(ONE_WIRE_PIN2); // set 1-wire high again,  
0CB9:  BSF    05.1
....................   delay_us( 2 ); // for more than 1us minimum.  
0CBA:  MOVLW  02
0CBB:  MOVWF  77
0CBC:  DECFSZ 77,F
0CBD:  GOTO   4BC
0CBE:  GOTO   4BF
0CBF:  NOP
....................  }  
0CC0:  BCF    03.5
0CC1:  INCF   48,F
0CC2:  GOTO   49D
.................... }  
0CC3:  RETURN
.................... /*********************** read1wire() *********************************/  
.................... /*This function reads the 8 -bit data via the 1-wire sensor. */  
.................... /* */  
.................... /*Parameters: */  
.................... /*Returns: 8-bit (1-byte) data from sensor */  
.................... /*********************************************************************/  
....................  
.................... int onewire1_read()  
.................... {  
....................  int count, data;  
....................  
....................  for (count=0; count<8; ++count)  
*
061A:  CLRF   47
061B:  MOVF   47,W
061C:  SUBLW  07
061D:  BTFSS  03.0
061E:  GOTO   640
....................  {  
....................   output_low(ONE_WIRE_PIN1);  
061F:  BSF    03.5
0620:  BCF    05.0
0621:  BCF    03.5
0622:  BCF    05.0
....................   delay_us( 2 ); // pull 1-wire low to initiate read time-slot.  
0623:  MOVLW  02
0624:  MOVWF  77
0625:  DECFSZ 77,F
0626:  GOTO   625
0627:  GOTO   628
0628:  NOP
....................   output_float(ONE_WIRE_PIN1); // now let 1-wire float high,  
0629:  BSF    03.5
062A:  BSF    05.0
....................   delay_us( 8 ); // let device state stabilise,  
062B:  MOVLW  0C
062C:  MOVWF  77
062D:  DECFSZ 77,F
062E:  GOTO   62D
062F:  GOTO   630
0630:  NOP
....................   shift_right(&data,1,input(ONE_WIRE_PIN1)); // and load result.  
0631:  BSF    05.0
0632:  BCF    03.5
0633:  BTFSC  05.0
0634:  GOTO   637
0635:  BCF    03.0
0636:  GOTO   638
0637:  BSF    03.0
0638:  RRF    48,F
....................   delay_us( 120 ); // wait until end of read slot.  
0639:  MOVLW  C7
063A:  MOVWF  77
063B:  DECFSZ 77,F
063C:  GOTO   63B
063D:  GOTO   63E
....................  }  
063E:  INCF   47,F
063F:  GOTO   61B
....................  
....................  return( data );  
0640:  MOVF   48,W
0641:  MOVWF  78
.................... } 
0642:  RETURN
....................  
.................... int onewire2_read() 
.................... {  
....................  int count, data;  
....................  
....................  for (count=0; count<8; ++count)  
*
0CC4:  CLRF   47
0CC5:  MOVF   47,W
0CC6:  SUBLW  07
0CC7:  BTFSS  03.0
0CC8:  GOTO   4EA
....................  {  
....................   output_low(ONE_WIRE_PIN2);  
0CC9:  BSF    03.5
0CCA:  BCF    05.1
0CCB:  BCF    03.5
0CCC:  BCF    05.1
....................   delay_us( 2 ); // pull 1-wire low to initiate read time-slot.  
0CCD:  MOVLW  02
0CCE:  MOVWF  77
0CCF:  DECFSZ 77,F
0CD0:  GOTO   4CF
0CD1:  GOTO   4D2
0CD2:  NOP
....................   output_float(ONE_WIRE_PIN2); // now let 1-wire float high,  
0CD3:  BSF    03.5
0CD4:  BSF    05.1
....................   delay_us( 8 ); // let device state stabilise,  
0CD5:  MOVLW  0C
0CD6:  MOVWF  77
0CD7:  DECFSZ 77,F
0CD8:  GOTO   4D7
0CD9:  GOTO   4DA
0CDA:  NOP
....................   shift_right(&data,1,input(ONE_WIRE_PIN2)); // and load result.  
0CDB:  BSF    05.1
0CDC:  BCF    03.5
0CDD:  BTFSC  05.1
0CDE:  GOTO   4E1
0CDF:  BCF    03.0
0CE0:  GOTO   4E2
0CE1:  BSF    03.0
0CE2:  RRF    48,F
....................   delay_us( 120 ); // wait until end of read slot.  
0CE3:  MOVLW  C7
0CE4:  MOVWF  77
0CE5:  DECFSZ 77,F
0CE6:  GOTO   4E5
0CE7:  GOTO   4E8
....................  }  
0CE8:  INCF   47,F
0CE9:  GOTO   4C5
....................  
....................  return( data );  
0CEA:  MOVF   48,W
0CEB:  MOVWF  78
.................... } 
0CEC:  RETURN
....................  
.................... #include <ds1820.c> 
.................... float ds1820_read1()  
.................... {  
*
0CF1:  CLRF   3E
....................  int8 busy=0, temp1, temp2;  
....................  signed int16 temp3;  
....................  float result;  
....................  
....................  onewire1_reset();  
0CF2:  BCF    0A.3
0CF3:  CALL   5D9
0CF4:  BSF    0A.3
....................  onewire1_write(0xCC);  
0CF5:  MOVLW  CC
0CF6:  MOVWF  47
0CF7:  BCF    0A.3
0CF8:  CALL   5F2
0CF9:  BSF    0A.3
....................  onewire1_write(0x44);  
0CFA:  MOVLW  44
0CFB:  MOVWF  47
0CFC:  BCF    0A.3
0CFD:  CALL   5F2
0CFE:  BSF    0A.3
....................  
....................  while (busy == 0)  
....................   busy = onewire1_read();  
0CFF:  MOVF   3E,F
0D00:  BTFSS  03.2
0D01:  GOTO   508
0D02:  BCF    0A.3
0D03:  CALL   61A
0D04:  BSF    0A.3
0D05:  MOVF   78,W
0D06:  MOVWF  3E
0D07:  GOTO   4FF
....................  
....................  onewire1_reset();  
0D08:  BCF    0A.3
0D09:  CALL   5D9
0D0A:  BSF    0A.3
....................  onewire1_write(0xCC);  
0D0B:  MOVLW  CC
0D0C:  MOVWF  47
0D0D:  BCF    0A.3
0D0E:  CALL   5F2
0D0F:  BSF    0A.3
....................  onewire1_write(0xBE);  
0D10:  MOVLW  BE
0D11:  MOVWF  47
0D12:  BCF    0A.3
0D13:  CALL   5F2
0D14:  BSF    0A.3
....................  temp1 = onewire1_read();  
0D15:  BCF    0A.3
0D16:  CALL   61A
0D17:  BSF    0A.3
0D18:  MOVF   78,W
0D19:  MOVWF  3F
....................  temp2 = onewire1_read();  
0D1A:  BCF    0A.3
0D1B:  CALL   61A
0D1C:  BSF    0A.3
0D1D:  MOVF   78,W
0D1E:  MOVWF  40
....................  temp3 = make16(temp2, temp1);  
0D1F:  MOVF   40,W
0D20:  MOVWF  42
0D21:  MOVF   3F,W
0D22:  MOVWF  41
....................    
.................... // result = (float) temp3 / 2.0;   //Calculation for DS18S20 with 0.5 deg C resolution  
....................  result = (float) temp3 / 16.0;  //Calculation for DS18B20 with 0.1 deg C resolution  
0D23:  MOVF   42,W
0D24:  MOVWF  48
0D25:  MOVF   41,W
0D26:  MOVWF  47
0D27:  BCF    0A.3
0D28:  CALL   643
0D29:  BSF    0A.3
0D2A:  MOVF   77,W
0D2B:  MOVWF  47
0D2C:  MOVF   78,W
0D2D:  MOVWF  48
0D2E:  MOVF   79,W
0D2F:  MOVWF  49
0D30:  MOVF   7A,W
0D31:  MOVWF  4A
0D32:  MOVWF  4E
0D33:  MOVF   79,W
0D34:  MOVWF  4D
0D35:  MOVF   78,W
0D36:  MOVWF  4C
0D37:  MOVF   77,W
0D38:  MOVWF  4B
0D39:  CLRF   52
0D3A:  CLRF   51
0D3B:  CLRF   50
0D3C:  MOVLW  83
0D3D:  MOVWF  4F
0D3E:  BCF    0A.3
0D3F:  CALL   668
0D40:  BSF    0A.3
0D41:  MOVF   7A,W
0D42:  MOVWF  46
0D43:  MOVF   79,W
0D44:  MOVWF  45
0D45:  MOVF   78,W
0D46:  MOVWF  44
0D47:  MOVF   77,W
0D48:  MOVWF  43
....................    
....................  delay_ms(200);  
0D49:  MOVLW  C8
0D4A:  MOVWF  4C
0D4B:  BCF    0A.3
0D4C:  CALL   090
0D4D:  BSF    0A.3
....................  return(result);  
0D4E:  MOVF   43,W
0D4F:  MOVWF  77
0D50:  MOVF   44,W
0D51:  MOVWF  78
0D52:  MOVF   45,W
0D53:  MOVWF  79
0D54:  MOVF   46,W
0D55:  MOVWF  7A
.................... } 
....................  
.................... float ds1820_read2()  
.................... {  
*
0D70:  CLRF   3E
....................  int8 busy=0, temp1, temp2;  
....................  signed int16 temp3;  
....................  float result;  
....................  
....................  onewire2_reset();  
0D71:  BCF    0A.3
0D72:  CALL   7DA
0D73:  BSF    0A.3
....................  onewire2_write(0xCC);  
0D74:  MOVLW  CC
0D75:  MOVWF  47
0D76:  CALL   49C
....................  onewire2_write(0x44);  
0D77:  MOVLW  44
0D78:  MOVWF  47
0D79:  CALL   49C
....................  
....................  while (busy == 0)  
....................   busy = onewire2_read();  
0D7A:  MOVF   3E,F
0D7B:  BTFSS  03.2
0D7C:  GOTO   581
0D7D:  CALL   4C4
0D7E:  MOVF   78,W
0D7F:  MOVWF  3E
0D80:  GOTO   57A
....................  
....................  onewire2_reset();  
0D81:  BCF    0A.3
0D82:  CALL   7DA
0D83:  BSF    0A.3
....................  onewire2_write(0xCC);  
0D84:  MOVLW  CC
0D85:  MOVWF  47
0D86:  CALL   49C
....................  onewire2_write(0xBE);  
0D87:  MOVLW  BE
0D88:  MOVWF  47
0D89:  CALL   49C
....................  temp1 = onewire2_read();  
0D8A:  CALL   4C4
0D8B:  MOVF   78,W
0D8C:  MOVWF  3F
....................  temp2 = onewire2_read();  
0D8D:  CALL   4C4
0D8E:  MOVF   78,W
0D8F:  MOVWF  40
....................  temp3 = make16(temp2, temp1);  
0D90:  MOVF   40,W
0D91:  MOVWF  42
0D92:  MOVF   3F,W
0D93:  MOVWF  41
....................    
.................... // result = (float) temp3 / 2.0;   //Calculation for DS18S20 with 0.5 deg C resolution  
....................  result = (float) temp3 / 16.0;  //Calculation for DS18B20 with 0.1 deg C resolution  
0D94:  MOVF   42,W
0D95:  MOVWF  48
0D96:  MOVF   41,W
0D97:  MOVWF  47
0D98:  BCF    0A.3
0D99:  CALL   643
0D9A:  BSF    0A.3
0D9B:  MOVF   77,W
0D9C:  MOVWF  47
0D9D:  MOVF   78,W
0D9E:  MOVWF  48
0D9F:  MOVF   79,W
0DA0:  MOVWF  49
0DA1:  MOVF   7A,W
0DA2:  MOVWF  4A
0DA3:  MOVWF  4E
0DA4:  MOVF   79,W
0DA5:  MOVWF  4D
0DA6:  MOVF   78,W
0DA7:  MOVWF  4C
0DA8:  MOVF   77,W
0DA9:  MOVWF  4B
0DAA:  CLRF   52
0DAB:  CLRF   51
0DAC:  CLRF   50
0DAD:  MOVLW  83
0DAE:  MOVWF  4F
0DAF:  BCF    0A.3
0DB0:  CALL   668
0DB1:  BSF    0A.3
0DB2:  MOVF   7A,W
0DB3:  MOVWF  46
0DB4:  MOVF   79,W
0DB5:  MOVWF  45
0DB6:  MOVF   78,W
0DB7:  MOVWF  44
0DB8:  MOVF   77,W
0DB9:  MOVWF  43
....................    
....................  delay_ms(200);  
0DBA:  MOVLW  C8
0DBB:  MOVWF  4C
0DBC:  BCF    0A.3
0DBD:  CALL   090
0DBE:  BSF    0A.3
....................  return(result);  
0DBF:  MOVF   43,W
0DC0:  MOVWF  77
0DC1:  MOVF   44,W
0DC2:  MOVWF  78
0DC3:  MOVF   45,W
0DC4:  MOVWF  79
0DC5:  MOVF   46,W
0DC6:  MOVWF  7A
.................... } 
....................  
.................... #include "DS1307.c" 
....................  
.................... #define RTC_SDA  PIN_C4 
.................... #define RTC_SCL  PIN_C3 
....................  
.................... #use i2c(master, fast, sda=RTC_SDA, scl=RTC_SCL) 
*
0140:  MOVLW  08
0141:  MOVWF  78
0142:  NOP
0143:  BCF    07.3
0144:  BCF    20.3
0145:  MOVF   20,W
0146:  BSF    03.5
0147:  MOVWF  07
0148:  NOP
0149:  BCF    03.5
014A:  RLF    42,F
014B:  BCF    07.4
014C:  BTFSS  03.0
014D:  GOTO   154
014E:  BSF    20.4
014F:  MOVF   20,W
0150:  BSF    03.5
0151:  MOVWF  07
0152:  GOTO   158
0153:  BCF    03.5
0154:  BCF    20.4
0155:  MOVF   20,W
0156:  BSF    03.5
0157:  MOVWF  07
0158:  NOP
0159:  BCF    03.5
015A:  BSF    20.3
015B:  MOVF   20,W
015C:  BSF    03.5
015D:  MOVWF  07
015E:  BCF    03.5
015F:  BTFSS  07.3
0160:  GOTO   15F
0161:  DECFSZ 78,F
0162:  GOTO   142
0163:  NOP
0164:  BCF    07.3
0165:  BCF    20.3
0166:  MOVF   20,W
0167:  BSF    03.5
0168:  MOVWF  07
0169:  NOP
016A:  BCF    03.5
016B:  BSF    20.4
016C:  MOVF   20,W
016D:  BSF    03.5
016E:  MOVWF  07
016F:  NOP
0170:  NOP
0171:  BCF    03.5
0172:  BSF    20.3
0173:  MOVF   20,W
0174:  BSF    03.5
0175:  MOVWF  07
0176:  BCF    03.5
0177:  BTFSS  07.3
0178:  GOTO   177
0179:  CLRF   78
017A:  NOP
017B:  BTFSC  07.4
017C:  BSF    78.0
017D:  BCF    07.3
017E:  BCF    20.3
017F:  MOVF   20,W
0180:  BSF    03.5
0181:  MOVWF  07
0182:  BCF    03.5
0183:  BCF    07.4
0184:  BCF    20.4
0185:  MOVF   20,W
0186:  BSF    03.5
0187:  MOVWF  07
0188:  BCF    03.5
0189:  RETURN
018A:  MOVLW  08
018B:  MOVWF  42
018C:  MOVF   77,W
018D:  MOVWF  43
018E:  BSF    20.4
018F:  MOVF   20,W
0190:  BSF    03.5
0191:  MOVWF  07
0192:  NOP
0193:  BCF    03.5
0194:  BSF    20.3
0195:  MOVF   20,W
0196:  BSF    03.5
0197:  MOVWF  07
0198:  BCF    03.5
0199:  BTFSS  07.3
019A:  GOTO   199
019B:  BTFSC  07.4
019C:  BSF    03.0
019D:  BTFSS  07.4
019E:  BCF    03.0
019F:  RLF    78,F
01A0:  NOP
01A1:  BCF    20.3
01A2:  MOVF   20,W
01A3:  BSF    03.5
01A4:  MOVWF  07
01A5:  BCF    03.5
01A6:  BCF    07.3
01A7:  DECFSZ 42,F
01A8:  GOTO   18E
01A9:  BSF    20.4
01AA:  MOVF   20,W
01AB:  BSF    03.5
01AC:  MOVWF  07
01AD:  NOP
01AE:  BCF    03.5
01AF:  BCF    07.4
01B0:  MOVF   43,W
01B1:  BTFSC  03.2
01B2:  GOTO   1B8
01B3:  BCF    20.4
01B4:  MOVF   20,W
01B5:  BSF    03.5
01B6:  MOVWF  07
01B7:  BCF    03.5
01B8:  NOP
01B9:  BSF    20.3
01BA:  MOVF   20,W
01BB:  BSF    03.5
01BC:  MOVWF  07
01BD:  BCF    03.5
01BE:  BTFSS  07.3
01BF:  GOTO   1BE
01C0:  NOP
01C1:  BCF    07.3
01C2:  BCF    20.3
01C3:  MOVF   20,W
01C4:  BSF    03.5
01C5:  MOVWF  07
01C6:  NOP
01C7:  BCF    03.5
01C8:  BCF    07.4
01C9:  BCF    20.4
01CA:  MOVF   20,W
01CB:  BSF    03.5
01CC:  MOVWF  07
01CD:  BCF    03.5
01CE:  RETURN
....................  
.................... //BYTE bin2bcd(BYTE binary_value); 
.................... //BYTE bcd2bin(BYTE bcd_value); 
....................  
.................... int8 bin2bcd(int8 binary_value) 
.................... { 
....................   int8 temp; 
....................   char retval; 
....................  
....................   temp = binary_value; 
*
01E2:  MOVF   41,W
01E3:  MOVWF  42
....................   retval = 0; 
01E4:  CLRF   43
....................  
....................   while(1) 
....................   { 
....................     // Get the tens digit by doing multiple subtraction 
....................     // of 10 from the binary value. 
....................     if(temp >= 10) 
01E5:  MOVF   42,W
01E6:  SUBLW  09
01E7:  BTFSC  03.0
01E8:  GOTO   1EE
....................     { 
....................       temp -= 10; 
01E9:  MOVLW  0A
01EA:  SUBWF  42,F
....................       retval += 0x10; 
01EB:  MOVLW  10
01EC:  ADDWF  43,F
....................     } 
....................     else // Get the ones digit by adding the remainder. 
01ED:  GOTO   1F1
....................     { 
....................       retval += temp; 
01EE:  MOVF   42,W
01EF:  ADDWF  43,F
....................       break; 
01F0:  GOTO   1F2
....................     } 
....................   } 
01F1:  GOTO   1E5
....................  
....................   return(retval); 
01F2:  MOVF   43,W
01F3:  MOVWF  78
.................... } 
01F4:  RETURN
....................  
.................... // Input range - 00 to 99. 
.................... char bcd2bin(char bcd_value) 
.................... { 
....................   char temp; 
....................  
....................   temp = bcd_value; 
*
01CF:  MOVF   42,W
01D0:  MOVWF  43
....................   // Shifting upper digit right by 1 is same as multiplying by 8. 
....................   temp >>= 1; 
01D1:  BCF    03.0
01D2:  RRF    43,F
....................   // Isolate the bits for the upper digit. 
....................   temp &= 0x78; 
01D3:  MOVLW  78
01D4:  ANDWF  43,F
....................  
....................   // Now return: (Tens * 8) + (Tens * 2) + Ones 
....................  
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
01D5:  RRF    43,W
01D6:  MOVWF  77
01D7:  RRF    77,F
01D8:  MOVLW  3F
01D9:  ANDWF  77,F
01DA:  MOVF   77,W
01DB:  ADDWF  43,W
01DC:  MOVWF  44
01DD:  MOVF   42,W
01DE:  ANDLW  0F
01DF:  ADDWF  44,W
01E0:  MOVWF  78
.................... } 
01E1:  RETURN
....................  
.................... void ds1307_init(void) 
.................... { 
*
104A:  CLRF   3E
....................    BYTE seconds = 0; 
....................  
....................    i2c_start(); 
104B:  BSF    20.4
104C:  MOVF   20,W
104D:  BSF    03.5
104E:  MOVWF  07
104F:  NOP
1050:  BCF    03.5
1051:  BSF    20.3
1052:  MOVF   20,W
1053:  BSF    03.5
1054:  MOVWF  07
1055:  NOP
1056:  BCF    03.5
1057:  BCF    07.4
1058:  BCF    20.4
1059:  MOVF   20,W
105A:  BSF    03.5
105B:  MOVWF  07
105C:  NOP
105D:  BCF    03.5
105E:  BCF    07.3
105F:  BCF    20.3
1060:  MOVF   20,W
1061:  BSF    03.5
1062:  MOVWF  07
....................    i2c_write(0xD0);      // WR to RTC 
1063:  MOVLW  D0
1064:  BCF    03.5
1065:  MOVWF  42
1066:  BCF    0A.4
1067:  CALL   140
1068:  BSF    0A.4
....................    i2c_write(0x00);      // REG 0 
1069:  CLRF   42
106A:  BCF    0A.4
106B:  CALL   140
106C:  BSF    0A.4
....................    i2c_start(); 
106D:  BSF    20.4
106E:  MOVF   20,W
106F:  BSF    03.5
1070:  MOVWF  07
1071:  NOP
1072:  BCF    03.5
1073:  BSF    20.3
1074:  MOVF   20,W
1075:  BSF    03.5
1076:  MOVWF  07
1077:  NOP
1078:  BCF    03.5
1079:  BTFSS  07.3
107A:  GOTO   079
107B:  BCF    07.4
107C:  BCF    20.4
107D:  MOVF   20,W
107E:  BSF    03.5
107F:  MOVWF  07
1080:  NOP
1081:  BCF    03.5
1082:  BCF    07.3
1083:  BCF    20.3
1084:  MOVF   20,W
1085:  BSF    03.5
1086:  MOVWF  07
....................    i2c_write(0xD1);      // RD from RTC 
1087:  MOVLW  D1
1088:  BCF    03.5
1089:  MOVWF  42
108A:  BCF    0A.4
108B:  CALL   140
108C:  BSF    0A.4
....................    seconds = bcd2bin(i2c_read(0)); // Read current "seconds" in DS1307 
108D:  CLRF   77
108E:  BCF    0A.4
108F:  CALL   18A
1090:  BSF    0A.4
1091:  MOVF   78,W
1092:  MOVWF  3F
1093:  MOVWF  42
1094:  BCF    0A.4
1095:  CALL   1CF
1096:  BSF    0A.4
1097:  MOVF   78,W
1098:  MOVWF  3E
....................    i2c_stop(); 
1099:  BCF    20.4
109A:  MOVF   20,W
109B:  BSF    03.5
109C:  MOVWF  07
109D:  NOP
109E:  BCF    03.5
109F:  BSF    20.3
10A0:  MOVF   20,W
10A1:  BSF    03.5
10A2:  MOVWF  07
10A3:  BCF    03.5
10A4:  BTFSS  07.3
10A5:  GOTO   0A4
10A6:  NOP
10A7:  GOTO   0A8
10A8:  NOP
10A9:  BSF    20.4
10AA:  MOVF   20,W
10AB:  BSF    03.5
10AC:  MOVWF  07
10AD:  NOP
....................    seconds &= 0x7F; 
10AE:  BCF    03.5
10AF:  BCF    3E.7
....................  
....................    delay_us(3); 
10B0:  MOVLW  04
10B1:  MOVWF  77
10B2:  DECFSZ 77,F
10B3:  GOTO   0B2
10B4:  GOTO   0B5
....................  
....................    i2c_start(); 
10B5:  BSF    20.4
10B6:  MOVF   20,W
10B7:  BSF    03.5
10B8:  MOVWF  07
10B9:  NOP
10BA:  BCF    03.5
10BB:  BSF    20.3
10BC:  MOVF   20,W
10BD:  BSF    03.5
10BE:  MOVWF  07
10BF:  NOP
10C0:  BCF    03.5
10C1:  BCF    07.4
10C2:  BCF    20.4
10C3:  MOVF   20,W
10C4:  BSF    03.5
10C5:  MOVWF  07
10C6:  NOP
10C7:  BCF    03.5
10C8:  BCF    07.3
10C9:  BCF    20.3
10CA:  MOVF   20,W
10CB:  BSF    03.5
10CC:  MOVWF  07
....................    i2c_write(0xD0);      // WR to RTC 
10CD:  MOVLW  D0
10CE:  BCF    03.5
10CF:  MOVWF  42
10D0:  BCF    0A.4
10D1:  CALL   140
10D2:  BSF    0A.4
....................    i2c_write(0x00);      // REG 0 
10D3:  CLRF   42
10D4:  BCF    0A.4
10D5:  CALL   140
10D6:  BSF    0A.4
....................    i2c_write(bin2bcd(seconds));     // Start oscillator with current "seconds value 
10D7:  MOVF   3E,W
10D8:  MOVWF  41
10D9:  BCF    0A.4
10DA:  CALL   1E2
10DB:  BSF    0A.4
10DC:  MOVF   78,W
10DD:  MOVWF  3F
10DE:  MOVWF  42
10DF:  BCF    0A.4
10E0:  CALL   140
10E1:  BSF    0A.4
....................    i2c_start(); 
10E2:  BSF    20.4
10E3:  MOVF   20,W
10E4:  BSF    03.5
10E5:  MOVWF  07
10E6:  NOP
10E7:  BCF    03.5
10E8:  BSF    20.3
10E9:  MOVF   20,W
10EA:  BSF    03.5
10EB:  MOVWF  07
10EC:  NOP
10ED:  BCF    03.5
10EE:  BTFSS  07.3
10EF:  GOTO   0EE
10F0:  BCF    07.4
10F1:  BCF    20.4
10F2:  MOVF   20,W
10F3:  BSF    03.5
10F4:  MOVWF  07
10F5:  NOP
10F6:  BCF    03.5
10F7:  BCF    07.3
10F8:  BCF    20.3
10F9:  MOVF   20,W
10FA:  BSF    03.5
10FB:  MOVWF  07
....................    i2c_write(0xD0);      // WR to RTC 
10FC:  MOVLW  D0
10FD:  BCF    03.5
10FE:  MOVWF  42
10FF:  BCF    0A.4
1100:  CALL   140
1101:  BSF    0A.4
....................    i2c_write(0x07);      // Control Register 
1102:  MOVLW  07
1103:  MOVWF  42
1104:  BCF    0A.4
1105:  CALL   140
1106:  BSF    0A.4
....................    i2c_write(0x80);     // Disable squarewave output pin 
1107:  MOVLW  80
1108:  MOVWF  42
1109:  BCF    0A.4
110A:  CALL   140
110B:  BSF    0A.4
....................    i2c_stop(); 
110C:  BCF    20.4
110D:  MOVF   20,W
110E:  BSF    03.5
110F:  MOVWF  07
1110:  NOP
1111:  BCF    03.5
1112:  BSF    20.3
1113:  MOVF   20,W
1114:  BSF    03.5
1115:  MOVWF  07
1116:  BCF    03.5
1117:  BTFSS  07.3
1118:  GOTO   117
1119:  NOP
111A:  GOTO   11B
111B:  NOP
111C:  BSF    20.4
111D:  MOVF   20,W
111E:  BSF    03.5
111F:  MOVWF  07
1120:  NOP
....................  
.................... } 
....................  
.................... void ds1307_set_date_time(BYTE day, int8 mth, BYTE year, BYTE dow, BYTE hr, BYTE min, BYTE sec) 
.................... { 
....................   sec &= 0x7F; 
....................   hr &= 0x3F; 
....................  
....................   i2c_start(); 
....................   i2c_write(0xD0);            // I2C write address 
....................   i2c_write(0x00);            // Start at REG 0 - Seconds 
....................   i2c_write(bin2bcd(sec));      // REG 0 
....................   i2c_write(bin2bcd(min));      // REG 1 
....................   i2c_write(bin2bcd(hr));      // REG 2 
....................   i2c_write(bin2bcd(dow));      // REG 3 
....................   i2c_write(bin2bcd(day));      // REG 4 
....................   i2c_write(bin2bcd(mth));      // REG 5 
....................   i2c_write(bin2bcd(year));      // REG 6 
....................   i2c_write(0x80);            // REG 7 - Disable squarewave output pin 
....................   i2c_stop(); 
.................... } 
....................  
.................... void ds1307_set_time(byte hr, byte min, byte sec) 
.................... { 
....................   sec &= 0x7F; 
*
02EE:  BCF    40.7
....................   hr &= 0x3F; 
02EF:  MOVLW  3F
02F0:  ANDWF  3E,F
....................   i2c_start(); 
02F1:  BSF    20.4
02F2:  MOVF   20,W
02F3:  BSF    03.5
02F4:  MOVWF  07
02F5:  NOP
02F6:  BCF    03.5
02F7:  BSF    20.3
02F8:  MOVF   20,W
02F9:  BSF    03.5
02FA:  MOVWF  07
02FB:  NOP
02FC:  BCF    03.5
02FD:  BCF    07.4
02FE:  BCF    20.4
02FF:  MOVF   20,W
0300:  BSF    03.5
0301:  MOVWF  07
0302:  NOP
0303:  BCF    03.5
0304:  BCF    07.3
0305:  BCF    20.3
0306:  MOVF   20,W
0307:  BSF    03.5
0308:  MOVWF  07
....................   i2c_write(0xD0);            // I2C write address 
0309:  MOVLW  D0
030A:  BCF    03.5
030B:  MOVWF  42
030C:  CALL   140
....................   i2c_write(0x00);            // Start at REG 0 - Seconds 
030D:  CLRF   42
030E:  CALL   140
....................   i2c_write(bin2bcd(sec));      // REG 0 
030F:  MOVF   40,W
0310:  MOVWF  41
0311:  CALL   1E2
0312:  MOVF   78,W
0313:  MOVWF  41
0314:  MOVWF  42
0315:  CALL   140
....................   i2c_write(bin2bcd(min));      // REG 1 
0316:  MOVF   3F,W
0317:  MOVWF  41
0318:  CALL   1E2
0319:  MOVF   78,W
031A:  MOVWF  41
031B:  MOVWF  42
031C:  CALL   140
....................   i2c_write(bin2bcd(hr));      // REG 2 
031D:  MOVF   3E,W
031E:  MOVWF  41
031F:  CALL   1E2
0320:  MOVF   78,W
0321:  MOVWF  41
0322:  MOVWF  42
0323:  CALL   140
....................   //i2c_write(0x80);            // REG 7 - Disable squarewave output pin 
....................   i2c_stop(); 
0324:  BCF    20.4
0325:  MOVF   20,W
0326:  BSF    03.5
0327:  MOVWF  07
0328:  NOP
0329:  BCF    03.5
032A:  BSF    20.3
032B:  MOVF   20,W
032C:  BSF    03.5
032D:  MOVWF  07
032E:  BCF    03.5
032F:  BTFSS  07.3
0330:  GOTO   32F
0331:  NOP
0332:  GOTO   333
0333:  NOP
0334:  BSF    20.4
0335:  MOVF   20,W
0336:  BSF    03.5
0337:  MOVWF  07
0338:  NOP
.................... } 
0339:  BCF    03.5
033A:  RETURN
....................  
.................... void ds1307_set_date(byte day, byte mth, byte year, byte dow) 
.................... { 
....................   
....................   i2c_start(); 
....................   i2c_write(0xD0);            // I2C write address 
....................   i2c_write(0x03);            // Start at REG 0 - Seconds 
....................   i2c_write(bin2bcd(dow)); 
....................   i2c_write(bin2bcd(day)); 
....................   i2c_write(bin2bcd(mth)); 
....................   i2c_write(bin2bcd(year)); 
....................   i2c_write(0x80);            // REG 7 - Disable squarewave output pin 
....................   i2c_stop(); 
.................... } 
....................  
.................... void ds1307_get_date(BYTE &day, BYTE &mth, BYTE &year, BYTE &dow) 
.................... { 
....................   i2c_start(); 
....................   i2c_write(0xD0); 
....................   i2c_write(0x03);            // Start at REG 3 - Day of week 
....................   i2c_start(); 
....................   i2c_write(0xD1); 
....................   dow  = bcd2bin(i2c_read() & 0x7f);   // REG 3 
....................   day  = bcd2bin(i2c_read() & 0x3f);   // REG 4 
....................   mth  = bcd2bin(i2c_read() & 0x1f);   // REG 5 
....................   year = bcd2bin(i2c_read(0));            // REG 6 
....................   i2c_stop(); 
.................... } 
....................  
.................... void ds1307_get_time(BYTE &hr, BYTE &min, BYTE &sec) 
.................... { 
....................   i2c_start(); 
*
04F7:  BSF    20.4
04F8:  MOVF   20,W
04F9:  BSF    03.5
04FA:  MOVWF  07
04FB:  NOP
04FC:  BCF    03.5
04FD:  BSF    20.3
04FE:  MOVF   20,W
04FF:  BSF    03.5
0500:  MOVWF  07
0501:  NOP
0502:  BCF    03.5
0503:  BCF    07.4
0504:  BCF    20.4
0505:  MOVF   20,W
0506:  BSF    03.5
0507:  MOVWF  07
0508:  NOP
0509:  BCF    03.5
050A:  BCF    07.3
050B:  BCF    20.3
050C:  MOVF   20,W
050D:  BSF    03.5
050E:  MOVWF  07
*
0E54:  BSF    20.4
0E55:  MOVF   20,W
0E56:  BSF    03.5
0E57:  MOVWF  07
0E58:  NOP
0E59:  BCF    03.5
0E5A:  BSF    20.3
0E5B:  MOVF   20,W
0E5C:  BSF    03.5
0E5D:  MOVWF  07
0E5E:  NOP
0E5F:  BCF    03.5
0E60:  BCF    07.4
0E61:  BCF    20.4
0E62:  MOVF   20,W
0E63:  BSF    03.5
0E64:  MOVWF  07
0E65:  NOP
0E66:  BCF    03.5
0E67:  BCF    07.3
0E68:  BCF    20.3
0E69:  MOVF   20,W
0E6A:  BSF    03.5
0E6B:  MOVWF  07
*
11AE:  BSF    20.4
11AF:  MOVF   20,W
11B0:  BSF    03.5
11B1:  MOVWF  07
11B2:  NOP
11B3:  BCF    03.5
11B4:  BSF    20.3
11B5:  MOVF   20,W
11B6:  BSF    03.5
11B7:  MOVWF  07
11B8:  NOP
11B9:  BCF    03.5
11BA:  BCF    07.4
11BB:  BCF    20.4
11BC:  MOVF   20,W
11BD:  BSF    03.5
11BE:  MOVWF  07
11BF:  NOP
11C0:  BCF    03.5
11C1:  BCF    07.3
11C2:  BCF    20.3
11C3:  MOVF   20,W
11C4:  BSF    03.5
11C5:  MOVWF  07
....................   i2c_write(0xD0); 
*
050F:  MOVLW  D0
0510:  BCF    03.5
0511:  MOVWF  42
0512:  CALL   140
*
0E6C:  MOVLW  D0
0E6D:  BCF    03.5
0E6E:  MOVWF  42
0E6F:  BCF    0A.3
0E70:  CALL   140
0E71:  BSF    0A.3
*
11C6:  MOVLW  D0
11C7:  BCF    03.5
11C8:  MOVWF  42
11C9:  BCF    0A.4
11CA:  CALL   140
11CB:  BSF    0A.4
....................   i2c_write(0x00);            // Start at REG 0 - Seconds 
*
0513:  CLRF   42
0514:  CALL   140
*
0E72:  CLRF   42
0E73:  BCF    0A.3
0E74:  CALL   140
0E75:  BSF    0A.3
*
11CC:  CLRF   42
11CD:  BCF    0A.4
11CE:  CALL   140
11CF:  BSF    0A.4
....................   i2c_start(); 
*
0515:  BSF    20.4
0516:  MOVF   20,W
0517:  BSF    03.5
0518:  MOVWF  07
0519:  NOP
051A:  BCF    03.5
051B:  BSF    20.3
051C:  MOVF   20,W
051D:  BSF    03.5
051E:  MOVWF  07
051F:  NOP
0520:  BCF    03.5
0521:  BTFSS  07.3
0522:  GOTO   521
0523:  BCF    07.4
0524:  BCF    20.4
0525:  MOVF   20,W
0526:  BSF    03.5
0527:  MOVWF  07
0528:  NOP
0529:  BCF    03.5
052A:  BCF    07.3
052B:  BCF    20.3
052C:  MOVF   20,W
052D:  BSF    03.5
052E:  MOVWF  07
*
0E76:  BSF    20.4
0E77:  MOVF   20,W
0E78:  BSF    03.5
0E79:  MOVWF  07
0E7A:  NOP
0E7B:  BCF    03.5
0E7C:  BSF    20.3
0E7D:  MOVF   20,W
0E7E:  BSF    03.5
0E7F:  MOVWF  07
0E80:  NOP
0E81:  BCF    03.5
0E82:  BTFSS  07.3
0E83:  GOTO   682
0E84:  BCF    07.4
0E85:  BCF    20.4
0E86:  MOVF   20,W
0E87:  BSF    03.5
0E88:  MOVWF  07
0E89:  NOP
0E8A:  BCF    03.5
0E8B:  BCF    07.3
0E8C:  BCF    20.3
0E8D:  MOVF   20,W
0E8E:  BSF    03.5
0E8F:  MOVWF  07
*
11D0:  BSF    20.4
11D1:  MOVF   20,W
11D2:  BSF    03.5
11D3:  MOVWF  07
11D4:  NOP
11D5:  BCF    03.5
11D6:  BSF    20.3
11D7:  MOVF   20,W
11D8:  BSF    03.5
11D9:  MOVWF  07
11DA:  NOP
11DB:  BCF    03.5
11DC:  BTFSS  07.3
11DD:  GOTO   1DC
11DE:  BCF    07.4
11DF:  BCF    20.4
11E0:  MOVF   20,W
11E1:  BSF    03.5
11E2:  MOVWF  07
11E3:  NOP
11E4:  BCF    03.5
11E5:  BCF    07.3
11E6:  BCF    20.3
11E7:  MOVF   20,W
11E8:  BSF    03.5
11E9:  MOVWF  07
....................   i2c_write(0xD1); 
*
052F:  MOVLW  D1
0530:  BCF    03.5
0531:  MOVWF  42
0532:  CALL   140
*
0E90:  MOVLW  D1
0E91:  BCF    03.5
0E92:  MOVWF  42
0E93:  BCF    0A.3
0E94:  CALL   140
0E95:  BSF    0A.3
*
11EA:  MOVLW  D1
11EB:  BCF    03.5
11EC:  MOVWF  42
11ED:  BCF    0A.4
11EE:  CALL   140
11EF:  BSF    0A.4
....................   sec = bcd2bin(i2c_read() & 0x7f); 
*
0533:  MOVLW  01
0534:  MOVWF  77
0535:  CALL   18A
0536:  MOVF   78,W
0537:  ANDLW  7F
0538:  MOVWF  3E
0539:  MOVWF  42
053A:  CALL   1CF
053B:  MOVF   78,W
053C:  MOVWF  21
*
0E96:  MOVLW  01
0E97:  MOVWF  77
0E98:  BCF    0A.3
0E99:  CALL   18A
0E9A:  BSF    0A.3
0E9B:  MOVF   78,W
0E9C:  ANDLW  7F
0E9D:  MOVWF  3E
0E9E:  MOVWF  42
0E9F:  BCF    0A.3
0EA0:  CALL   1CF
0EA1:  BSF    0A.3
0EA2:  MOVF   78,W
0EA3:  MOVWF  21
*
11F0:  MOVLW  01
11F1:  MOVWF  77
11F2:  BCF    0A.4
11F3:  CALL   18A
11F4:  BSF    0A.4
11F5:  MOVF   78,W
11F6:  ANDLW  7F
11F7:  MOVWF  3E
11F8:  MOVWF  42
11F9:  BCF    0A.4
11FA:  CALL   1CF
11FB:  BSF    0A.4
11FC:  MOVF   78,W
11FD:  MOVWF  21
....................   min = bcd2bin(i2c_read() & 0x7f); 
*
053D:  MOVLW  01
053E:  MOVWF  77
053F:  CALL   18A
0540:  MOVF   78,W
0541:  ANDLW  7F
0542:  MOVWF  3E
0543:  MOVWF  42
0544:  CALL   1CF
0545:  MOVF   78,W
0546:  MOVWF  35
*
0EA4:  MOVLW  01
0EA5:  MOVWF  77
0EA6:  BCF    0A.3
0EA7:  CALL   18A
0EA8:  BSF    0A.3
0EA9:  MOVF   78,W
0EAA:  ANDLW  7F
0EAB:  MOVWF  3E
0EAC:  MOVWF  42
0EAD:  BCF    0A.3
0EAE:  CALL   1CF
0EAF:  BSF    0A.3
0EB0:  MOVF   78,W
0EB1:  MOVWF  22
*
11FE:  MOVLW  01
11FF:  MOVWF  77
1200:  BCF    0A.4
1201:  CALL   18A
1202:  BSF    0A.4
1203:  MOVF   78,W
1204:  ANDLW  7F
1205:  MOVWF  3E
1206:  MOVWF  42
1207:  BCF    0A.4
1208:  CALL   1CF
1209:  BSF    0A.4
120A:  MOVF   78,W
120B:  MOVWF  22
....................   hr  = bcd2bin(i2c_read(0) & 0x3f); 
*
0547:  CLRF   77
0548:  CALL   18A
0549:  MOVF   78,W
054A:  ANDLW  3F
054B:  MOVWF  3E
054C:  MOVWF  42
054D:  CALL   1CF
054E:  MOVF   78,W
054F:  MOVWF  34
*
0EB2:  CLRF   77
0EB3:  BCF    0A.3
0EB4:  CALL   18A
0EB5:  BSF    0A.3
0EB6:  MOVF   78,W
0EB7:  ANDLW  3F
0EB8:  MOVWF  3E
0EB9:  MOVWF  42
0EBA:  BCF    0A.3
0EBB:  CALL   1CF
0EBC:  BSF    0A.3
0EBD:  MOVF   78,W
0EBE:  MOVWF  23
*
120C:  CLRF   77
120D:  BCF    0A.4
120E:  CALL   18A
120F:  BSF    0A.4
1210:  MOVF   78,W
1211:  ANDLW  3F
1212:  MOVWF  3E
1213:  MOVWF  42
1214:  BCF    0A.4
1215:  CALL   1CF
1216:  BSF    0A.4
1217:  MOVF   78,W
1218:  MOVWF  23
....................   i2c_stop(); 
*
0550:  BCF    20.4
0551:  MOVF   20,W
0552:  BSF    03.5
0553:  MOVWF  07
0554:  NOP
0555:  BCF    03.5
0556:  BSF    20.3
0557:  MOVF   20,W
0558:  BSF    03.5
0559:  MOVWF  07
055A:  BCF    03.5
055B:  BTFSS  07.3
055C:  GOTO   55B
055D:  NOP
055E:  GOTO   55F
055F:  NOP
0560:  BSF    20.4
0561:  MOVF   20,W
0562:  BSF    03.5
0563:  MOVWF  07
0564:  NOP
*
0EBF:  BCF    20.4
0EC0:  MOVF   20,W
0EC1:  BSF    03.5
0EC2:  MOVWF  07
0EC3:  NOP
0EC4:  BCF    03.5
0EC5:  BSF    20.3
0EC6:  MOVF   20,W
0EC7:  BSF    03.5
0EC8:  MOVWF  07
0EC9:  BCF    03.5
0ECA:  BTFSS  07.3
0ECB:  GOTO   6CA
0ECC:  NOP
0ECD:  GOTO   6CE
0ECE:  NOP
0ECF:  BSF    20.4
0ED0:  MOVF   20,W
0ED1:  BSF    03.5
0ED2:  MOVWF  07
0ED3:  NOP
*
1219:  BCF    20.4
121A:  MOVF   20,W
121B:  BSF    03.5
121C:  MOVWF  07
121D:  NOP
121E:  BCF    03.5
121F:  BSF    20.3
1220:  MOVF   20,W
1221:  BSF    03.5
1222:  MOVWF  07
1223:  BCF    03.5
1224:  BTFSS  07.3
1225:  GOTO   224
1226:  NOP
1227:  GOTO   228
1228:  NOP
1229:  BSF    20.4
122A:  MOVF   20,W
122B:  BSF    03.5
122C:  MOVWF  07
122D:  NOP
....................  
.................... }  
....................  
....................  
.................... ///////////////////////////////// Definiciones de Pines ///////////////////////////////// 
.................... #define TRMP1     PIN_A0  // Temperatura one wire (DS18B20) 1 
.................... #define TRMP2     PIN_A1  // Temperatura one wire (DS18B20) 2 
.................... #define TRMP3     PIN_A2  // Temperatura aux 
....................  
.................... #define CALOR1    PIN_B1  // Resistencias 1 (1 unidad RECO 2kW) 
.................... #define CALOR2    PIN_B2  // Resistencias 2 (1 unidad RECO 2kW) 
.................... #define CALOR3    PIN_B3  // Resistencias 3 (1 unidad RECO 2kW) 
.................... #define CALOR4    PIN_B0  // Resistencias 4 (1 unidad RECO 2kW) 
....................  
.................... #define ARRIBA    PIN_C0  // Pulsador 1 (Arriba) 
.................... #define ABAJO     PIN_C1  // Pulsador 2 (Abajo) 
.................... #define PROX      PIN_C2  // Pulsador 3 (Siguiente) 
.................... #define TECLA4    PIN_B4  // Auxiliar 
.................... #define TECLA5    PIN_B5  // Auxiliar 
....................  
.................... #define RELE3     PIN_D0  // Rele de bomba centrifuga 
.................... #define BBA       PIN_D1  // Rele de electrovalvula 
.................... #define VALVE     PIN_D2  // Rele auxiliar 
....................  
.................... #define LLENADO   PIN_A3  // Fin de carrera de llenado por evaporacion AN3 
.................... #define FCARRERA  PIN_A4  // Fin de carrera de corte por falta de nivel critico NoAN 
.................... #define CRITICO   PIN_A5  // Fin de carrera auxiliar AN4 
.................... ///////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /// Definiciones de posiciones de memoria 
.................... #define HSENCENDIDO    20 
.................... #define HSAPAGADO      22 
.................... #define POTMAX         24 
.................... #define TERMOSTAT      26 
....................  
.................... ////// Variables del DS1307 ///// 
.................... int sec; 
.................... int min; 
.................... int hrs; 
.................... ///////////////////////////////// 
....................  
.................... /*  EN EL LCD 
.................... #define LCD_DB4   PIN_D4 
.................... #define LCD_DB5   PIN_C7 
.................... #define LCD_DB6   PIN_C6 
.................... #define LCD_DB7   PIN_C5 
....................  
.................... #define LCD_E     PIN_D5 
.................... #define LCD_RS    PIN_D7 
.................... #define LCD_RW    PIN_D5 
.................... */ 
.................... /////////////////// Funciones /////////////////////// 
.................... void Inicio(); 
.................... void LeaTemp(); 
.................... void SaleCalor(int RR); 
.................... void Teclado(); 
.................... void Pantalla(); 
.................... void Tiempo(); 
.................... void Calefa(); 
.................... void Automa(); 
.................... void Criticos(); 
.................... void ShutDown(); 
.................... void Apagado(); 
.................... void LeaAnalog(); 
.................... ///////////////////////////////////////////////////// 
....................  
.................... /////////////// VARIABLES GLOBALES /////////////// 
.................... short Rebote; 
.................... int Menu; 
.................... float TempIn;        // Temperatura Sensor 1 (entrada fria) 
.................... float TempOut;       // Temperatura Sensor 2 (salida caliente) 
.................... int intTempIn;       // Temperatura Sensor 1 (entrada fria) 
.................... int intTempOut;      // Temperatura Sensor 2 (salida caliente) 
.................... int Termostato;      // Temperatura del termostato 
.................... int HsOn;            // Hs de Encendido de Caldera 
.................... int HsOff;           // Hs de Apagado de Caldera 
.................... int MaxPower;        // Potencia Maxima 
.................... int HsConfig;        // Hora temporal para configuracion 
.................... int MinConfig;       // Minuto temporal para configuracion 
.................... int PotActual;       // Potencia Actual 
.................... int EstadoCritico;   // Almacena el estado de funcionamiento de la caldera 
.................... int ii;              // Contador complejo 
.................... int CritExS1;        // Contador de exceso critico de temperatura en Sensor1 
.................... int CritExS2;        // Contador de exceso critico de temperatura en Sensor2 
.................... int CritErS1;        // Contador de errores criticos en lectura de temperatura en Sensor1 
.................... int CritErS2;        // Contador de errores criticos en lectura de temperatura en Sensor2 
.................... short Llenar;        // Variable de llenado con electro sin error 
.................... short NCritico;      // Variable de corte por nivel critico 
....................  
.................... ////////////////////////////////////////////////// 
....................  
.................... void main(){ 
*
124E:  CLRF   04
124F:  BCF    03.7
1250:  MOVLW  1F
1251:  ANDWF  03,F
1252:  MOVLW  FF
1253:  MOVWF  20
1254:  BSF    03.5
1255:  BSF    1F.0
1256:  BSF    1F.1
1257:  BSF    1F.2
1258:  BCF    1F.3
1259:  MOVLW  07
125A:  MOVWF  1C
.................... int Aux; 
.................... Inicio(); 
125B:  BCF    03.5
125C:  GOTO   000
.................... LeaAnalog(); 
125D:  BCF    0A.4
125E:  BSF    0A.3
125F:  CALL   5DF
1260:  BSF    0A.4
1261:  BCF    0A.3
.................... while (1) { 
.................... /* 
.................... while (1){ 
.................... lcd_putc("\f");  
.................... LeaAnalog(); 
.................... restart_wdt(); // Reiniciamos el perro 
.................... }*/ 
....................  
.................... ++Aux; 
1262:  INCF   3D,F
.................... if (Aux == 255) { // Cada mas o menos 5 segundos 
1263:  INCFSZ 3D,W
1264:  GOTO   28A
.................... ++ii; 
1265:  INCF   38,F
.................... LeaAnalog(); 
1266:  BCF    0A.4
1267:  BSF    0A.3
1268:  CALL   5DF
1269:  BSF    0A.4
126A:  BCF    0A.3
.................... restart_wdt(); // Reiniciamos el perro 
126B:  CLRWDT
.................... LeaTemp(); 
126C:  BCF    0A.4
126D:  BSF    0A.3
126E:  CALL   4ED
126F:  BSF    0A.4
1270:  BCF    0A.3
.................... restart_wdt(); // Reiniciamos el perro 
1271:  CLRWDT
.................... Automa(); 
1272:  BCF    0A.4
1273:  BSF    0A.3
1274:  GOTO   629
1275:  BSF    0A.4
1276:  BCF    0A.3
.................... if (Llenar == True) output_high(VALVE); 
1277:  BTFSS  24.1
1278:  GOTO   27E
1279:  BSF    03.5
127A:  BCF    08.2
127B:  BCF    03.5
127C:  BSF    08.2
.................... else output_low(VALVE); 
127D:  GOTO   282
127E:  BSF    03.5
127F:  BCF    08.2
1280:  BCF    03.5
1281:  BCF    08.2
.................... if ((ii % 4) == 0) { // reseteo variables de error 
1282:  MOVF   38,W
1283:  ANDLW  03
1284:  BTFSS  03.2
1285:  GOTO   28A
.................... CritExS1 = 0; 
1286:  CLRF   39
.................... CritExS2 = 0; 
1287:  CLRF   3A
.................... CritErS1 = 0; 
1288:  CLRF   3B
.................... CritErS2 = 0; 
1289:  CLRF   3C
.................... } // reset error 
.................... } // Cada 5 segundos 
....................  
.................... restart_wdt(); // Reiniciamos el perro 
128A:  CLRWDT
.................... Tiempo(); 
128B:  BCF    0A.4
128C:  BSF    0A.3
128D:  GOTO   654
128E:  BSF    0A.4
128F:  BCF    0A.3
.................... restart_wdt(); // Reiniciamos el perro 
1290:  CLRWDT
.................... Teclado(); 
1291:  BCF    0A.4
1292:  CALL   33B
1293:  BSF    0A.4
.................... restart_wdt(); // Reiniciamos el perro 
1294:  CLRWDT
.................... Pantalla(); 
1295:  BCF    0A.4
1296:  BSF    0A.3
1297:  CALL   27D
1298:  BSF    0A.4
1299:  BCF    0A.3
.................... restart_wdt(); // Reiniciamos el perro 
129A:  CLRWDT
....................  
.................... Criticos(); // dentro de esta se llama a Calefa(); 
129B:  BCF    0A.4
129C:  BSF    0A.3
129D:  GOTO   6F7
129E:  BSF    0A.4
129F:  BCF    0A.3
.................... restart_wdt(); // Reiniciamos el perro 
12A0:  CLRWDT
.................... } // while 1 
12A1:  GOTO   262
.................... } // main 
....................  
....................  
.................... void Inicio(){ 
.................... setup_wdt(WDT_2304MS); // Perro mas largo 
*
1000:  MOVLW  0F
1001:  MOVWF  77
1002:  CLRF   01
1003:  MOVLW  81
1004:  MOVWF  04
1005:  BCF    03.7
1006:  MOVF   00,W
1007:  ANDLW  F0
1008:  IORLW  07
1009:  MOVWF  00
100A:  CLRWDT
100B:  MOVF   00,W
100C:  ANDLW  F7
100D:  BTFSC  77.3
100E:  ANDLW  F0
100F:  IORWF  77,W
1010:  MOVWF  00
*
12A2:  SLEEP
.................... lcd_init(); 
.................... DS1307_init(); 
.................... delay_ms(5); 
*
1121:  MOVLW  05
1122:  BCF    03.5
1123:  MOVWF  4C
1124:  BCF    0A.4
1125:  CALL   090
1126:  BSF    0A.4
.................... lcd_putc("\f");  
1127:  MOVLW  0C
1128:  BSF    03.6
1129:  MOVWF  0D
112A:  MOVLW  00
112B:  MOVWF  0F
112C:  BCF    0A.4
112D:  BCF    03.6
112E:  CALL   22B
112F:  BSF    0A.4
....................  
.................... setup_adc_ports(NO_ANALOGS); 
1130:  BSF    03.5
1131:  BSF    1F.0
1132:  BSF    1F.1
1133:  BSF    1F.2
1134:  BCF    1F.3
.................... setup_adc(ADC_OFF);  
1135:  BCF    03.5
1136:  BCF    1F.0
.................... setup_psp(PSP_DISABLED);  
1137:  BSF    03.5
1138:  BCF    09.4
.................... setup_spi(FALSE);  
1139:  BCF    03.5
113A:  CLRF   14
.................... setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1);  
113B:  BSF    03.5
113C:  MOVF   01,W
113D:  ANDLW  C7
113E:  IORLW  08
113F:  MOVWF  01
.................... setup_timer_1(T1_DISABLED);  
1140:  BCF    03.5
1141:  CLRF   10
.................... setup_timer_2(T2_DISABLED,0,1);  
1142:  MOVLW  00
1143:  MOVWF  78
1144:  MOVWF  12
1145:  MOVLW  00
1146:  BSF    03.5
1147:  MOVWF  12
.................... setup_comparator(NC_NC_NC_NC);  
1148:  MOVLW  07
1149:  MOVWF  1C
114A:  MOVF   05,W
114B:  MOVWF  05
114C:  MOVLW  10
114D:  MOVWF  77
114E:  DECFSZ 77,F
114F:  GOTO   14E
1150:  NOP
1151:  MOVF   1C,W
1152:  BCF    03.5
1153:  BCF    0D.6
.................... setup_vref(VREF_LOW|-2);  
1154:  MOVLW  FE
1155:  BSF    03.5
1156:  MOVWF  1D
1157:  BSF    05.2
....................  
.................... HsOn = read_eeprom(HSENCENDIDO); 
1158:  MOVLW  14
1159:  BCF    03.5
115A:  BSF    03.6
115B:  MOVWF  0D
115C:  BSF    03.5
115D:  BCF    0C.7
115E:  BSF    0C.0
115F:  BCF    03.5
1160:  MOVF   0C,W
1161:  BCF    03.6
1162:  MOVWF  31
.................... if (HsOn > 47) HsOn = 36;  
1163:  MOVF   31,W
1164:  SUBLW  2F
1165:  BTFSC  03.0
1166:  GOTO   169
1167:  MOVLW  24
1168:  MOVWF  31
.................... HsOff = read_eeprom(HSAPAGADO); 
1169:  MOVLW  16
116A:  BSF    03.6
116B:  MOVWF  0D
116C:  BSF    03.5
116D:  BCF    0C.7
116E:  BSF    0C.0
116F:  BCF    03.5
1170:  MOVF   0C,W
1171:  BCF    03.6
1172:  MOVWF  32
.................... if (HsOff > 47) HsOff = 12;  
1173:  MOVF   32,W
1174:  SUBLW  2F
1175:  BTFSC  03.0
1176:  GOTO   179
1177:  MOVLW  0C
1178:  MOVWF  32
.................... MaxPower = read_eeprom(POTMAX); 
1179:  MOVLW  18
117A:  BSF    03.6
117B:  MOVWF  0D
117C:  BSF    03.5
117D:  BCF    0C.7
117E:  BSF    0C.0
117F:  BCF    03.5
1180:  MOVF   0C,W
1181:  BCF    03.6
1182:  MOVWF  33
.................... if ((MaxPower > 4) || (MaxPower == 0)) MaxPower = 4; // Potencia multiplica por 2  
1183:  MOVF   33,W
1184:  SUBLW  04
1185:  BTFSS  03.0
1186:  GOTO   18A
1187:  MOVF   33,F
1188:  BTFSS  03.2
1189:  GOTO   18C
118A:  MOVLW  04
118B:  MOVWF  33
.................... Termostato = read_eeprom(TERMOSTAT); 
118C:  MOVLW  1A
118D:  BSF    03.6
118E:  MOVWF  0D
118F:  BSF    03.5
1190:  BCF    0C.7
1191:  BSF    0C.0
1192:  BCF    03.5
1193:  MOVF   0C,W
1194:  BCF    03.6
1195:  MOVWF  30
.................... if ((Termostato > 18) || (Termostato < 3)) Termostato = 13; // Temperatura multiplica por 5 
1196:  MOVF   30,W
1197:  SUBLW  12
1198:  BTFSS  03.0
1199:  GOTO   19E
119A:  MOVF   30,W
119B:  SUBLW  02
119C:  BTFSS  03.0
119D:  GOTO   1A0
119E:  MOVLW  0D
119F:  MOVWF  30
....................  
.................... Menu = 1; 
11A0:  MOVLW  01
11A1:  MOVWF  25
.................... ii = 0; 
11A2:  CLRF   38
.................... Llenar = 0; 
11A3:  BCF    24.1
.................... NCritico = 0; 
11A4:  BCF    24.2
.................... CritExS1 = 0; 
11A5:  CLRF   39
.................... CritExS2 = 0; 
11A6:  CLRF   3A
.................... CritErS1 = 0; 
11A7:  CLRF   3B
.................... CritErS2 = 0; 
11A8:  CLRF   3C
.................... EstadoCritico = 0; 
11A9:  CLRF   37
.................... SaleCalor(0); 
11AA:  CLRF   40
11AB:  BCF    0A.4
11AC:  CALL   276
11AD:  BSF    0A.4
.................... ds1307_get_time(hrs,min,sec); 
.................... delay_ms(2); 
*
122E:  MOVLW  02
122F:  BCF    03.5
1230:  MOVWF  4C
1231:  BCF    0A.4
1232:  CALL   090
1233:  BSF    0A.4
.................... if ((hrs > 23) || (min > 59) || (sec > 59)) ds1307_set_time(0, 0, 0); 
1234:  MOVF   23,W
1235:  SUBLW  17
1236:  BTFSS  03.0
1237:  GOTO   240
1238:  MOVF   22,W
1239:  SUBLW  3B
123A:  BTFSS  03.0
123B:  GOTO   240
123C:  MOVF   21,W
123D:  SUBLW  3B
123E:  BTFSC  03.0
123F:  GOTO   246
1240:  CLRF   3E
1241:  CLRF   3F
1242:  CLRF   40
1243:  BCF    0A.4
1244:  CALL   2EE
1245:  BSF    0A.4
.................... LeaTemp(); // Para que lea la temperatura por primera vez y no nos tire error 
1246:  BCF    0A.4
1247:  BSF    0A.3
1248:  CALL   4ED
1249:  BSF    0A.4
124A:  BCF    0A.3
.................... } 
124B:  BCF    0A.3
124C:  BSF    0A.4
124D:  GOTO   25D (RETURN)
....................  
.................... void LeaAnalog(){ 
.................... restart_wdt(); // Reiniciamos el perro 
*
0DDF:  CLRWDT
.................... int  val; 
.................... int  V1; 
.................... int  V2; 
....................  
.................... setup_adc(ADC_CLOCK_INTERNAL); 
0DE0:  BSF    03.5
0DE1:  BCF    1F.6
0DE2:  BCF    03.5
0DE3:  BSF    1F.6
0DE4:  BSF    1F.7
0DE5:  BSF    03.5
0DE6:  BCF    1F.7
0DE7:  BCF    03.5
0DE8:  BSF    1F.0
.................... setup_adc_ports(AN0_AN1_AN2_AN3_AN4); 
0DE9:  BSF    03.5
0DEA:  BCF    1F.0
0DEB:  BSF    1F.1
0DEC:  BCF    1F.2
0DED:  BCF    1F.3
....................  
.................... set_adc_channel(3); 
0DEE:  MOVLW  18
0DEF:  MOVWF  78
0DF0:  BCF    03.5
0DF1:  MOVF   1F,W
0DF2:  ANDLW  C7
0DF3:  IORWF  78,W
0DF4:  MOVWF  1F
.................... delay_ms(5); 
0DF5:  MOVLW  05
0DF6:  MOVWF  4C
0DF7:  BCF    0A.3
0DF8:  CALL   090
0DF9:  BSF    0A.3
.................... val = read_adc(); 
0DFA:  BSF    1F.2
0DFB:  BTFSC  1F.2
0DFC:  GOTO   5FB
0DFD:  MOVF   1E,W
0DFE:  MOVWF  3E
.................... V1 = val; 
0DFF:  MOVF   3E,W
0E00:  MOVWF  3F
.................... if (val > 170) Llenar = True; 
0E01:  MOVF   3E,W
0E02:  SUBLW  AA
0E03:  BTFSC  03.0
0E04:  GOTO   607
0E05:  BSF    24.1
.................... else Llenar = False; 
0E06:  GOTO   608
0E07:  BCF    24.1
....................  
.................... set_adc_channel(4); 
0E08:  MOVLW  20
0E09:  MOVWF  78
0E0A:  MOVF   1F,W
0E0B:  ANDLW  C7
0E0C:  IORWF  78,W
0E0D:  MOVWF  1F
.................... delay_ms(5); 
0E0E:  MOVLW  05
0E0F:  MOVWF  4C
0E10:  BCF    0A.3
0E11:  CALL   090
0E12:  BSF    0A.3
.................... val = read_adc(); 
0E13:  BSF    1F.2
0E14:  BTFSC  1F.2
0E15:  GOTO   614
0E16:  MOVF   1E,W
0E17:  MOVWF  3E
.................... V2 = val; 
0E18:  MOVF   3E,W
0E19:  MOVWF  40
.................... if (val > 170) NCritico = True; 
0E1A:  MOVF   3E,W
0E1B:  SUBLW  AA
0E1C:  BTFSC  03.0
0E1D:  GOTO   620
0E1E:  BSF    24.2
.................... else NCritico = False; 
0E1F:  GOTO   621
0E20:  BCF    24.2
....................  
.................... setup_adc_ports(NO_ANALOGS); 
0E21:  BSF    03.5
0E22:  BSF    1F.0
0E23:  BSF    1F.1
0E24:  BSF    1F.2
0E25:  BCF    1F.3
.................... setup_adc(ADC_OFF);  
0E26:  BCF    03.5
0E27:  BCF    1F.0
.................... /* 
.................... lcd_gotoxy(1,1); 
.................... printf(lcd_putc,"V1 %03u", V1); 
.................... lcd_gotoxy(1,2); 
.................... printf(lcd_putc,"V2 %03u", V2); 
.................... restart_wdt(); // Reiniciamos el perro 
.................... delay_ms(200); 
.................... restart_wdt(); // Reiniciamos el perro 
.................... */ 
.................... } //Fn 
0E28:  RETURN
....................  
.................... void LeaTemp(){ 
.................... restart_wdt(); // Reiniciamos el perro 
*
0CED:  CLRWDT
.................... Teclado(); 
0CEE:  BCF    0A.3
0CEF:  CALL   33B
0CF0:  BSF    0A.3
.................... TempIn = ds1820_read1();  
*
0D56:  MOVF   7A,W
0D57:  MOVWF  29
0D58:  MOVF   79,W
0D59:  MOVWF  28
0D5A:  MOVF   78,W
0D5B:  MOVWF  27
0D5C:  MOVF   77,W
0D5D:  MOVWF  26
.................... intTempIn = (int) TempIn; 
0D5E:  MOVF   29,W
0D5F:  MOVWF  41
0D60:  MOVF   28,W
0D61:  MOVWF  40
0D62:  MOVF   27,W
0D63:  MOVWF  3F
0D64:  MOVF   26,W
0D65:  MOVWF  3E
0D66:  BCF    0A.3
0D67:  CALL   732
0D68:  BSF    0A.3
0D69:  MOVF   78,W
0D6A:  MOVWF  2E
.................... Pantalla(); 
0D6B:  CALL   27D
.................... restart_wdt(); // Reiniciamos el perro 
0D6C:  CLRWDT
.................... Teclado(); 
0D6D:  BCF    0A.3
0D6E:  CALL   33B
0D6F:  BSF    0A.3
.................... TempOut = ds1820_read2(); 
*
0DC7:  MOVF   7A,W
0DC8:  MOVWF  2D
0DC9:  MOVF   79,W
0DCA:  MOVWF  2C
0DCB:  MOVF   78,W
0DCC:  MOVWF  2B
0DCD:  MOVF   77,W
0DCE:  MOVWF  2A
.................... intTempOut = (int) TempOut; 
0DCF:  MOVF   2D,W
0DD0:  MOVWF  41
0DD1:  MOVF   2C,W
0DD2:  MOVWF  40
0DD3:  MOVF   2B,W
0DD4:  MOVWF  3F
0DD5:  MOVF   2A,W
0DD6:  MOVWF  3E
0DD7:  BCF    0A.3
0DD8:  CALL   732
0DD9:  BSF    0A.3
0DDA:  MOVF   78,W
0DDB:  MOVWF  2F
.................... Pantalla(); 
0DDC:  CALL   27D
.................... restart_wdt(); // Reiniciamos el perro 
0DDD:  CLRWDT
.................... } 
0DDE:  RETURN
....................  
.................... void SaleCalor(int RR){ 
.................... switch(RR) 
.................... { 
*
0276:  MOVF   40,W
0277:  ADDLW  FB
0278:  BTFSC  03.0
0279:  GOTO   2E1
027A:  ADDLW  05
027B:  GOTO   2E5
....................    case 0: 
....................       output_low(CALOR1); 
027C:  BSF    03.5
027D:  BCF    06.1
027E:  BCF    03.5
027F:  BCF    06.1
....................       output_low(CALOR2); 
0280:  BSF    03.5
0281:  BCF    06.2
0282:  BCF    03.5
0283:  BCF    06.2
....................       output_low(CALOR3); 
0284:  BSF    03.5
0285:  BCF    06.3
0286:  BCF    03.5
0287:  BCF    06.3
....................       output_low(CALOR4); 
0288:  BSF    03.5
0289:  BCF    06.0
028A:  BCF    03.5
028B:  BCF    06.0
....................       break; 
028C:  GOTO   2E1
....................  
....................    case 1: 
....................       output_high(CALOR1); 
028D:  BSF    03.5
028E:  BCF    06.1
028F:  BCF    03.5
0290:  BSF    06.1
....................       output_low(CALOR2); 
0291:  BSF    03.5
0292:  BCF    06.2
0293:  BCF    03.5
0294:  BCF    06.2
....................       output_low(CALOR3); 
0295:  BSF    03.5
0296:  BCF    06.3
0297:  BCF    03.5
0298:  BCF    06.3
....................       output_low(CALOR4); 
0299:  BSF    03.5
029A:  BCF    06.0
029B:  BCF    03.5
029C:  BCF    06.0
....................       break; 
029D:  GOTO   2E1
....................  
....................    case 2: 
....................       output_low(CALOR1); 
029E:  BSF    03.5
029F:  BCF    06.1
02A0:  BCF    03.5
02A1:  BCF    06.1
....................       output_high(CALOR2); 
02A2:  BSF    03.5
02A3:  BCF    06.2
02A4:  BCF    03.5
02A5:  BSF    06.2
....................       output_high(CALOR3); 
02A6:  BSF    03.5
02A7:  BCF    06.3
02A8:  BCF    03.5
02A9:  BSF    06.3
....................       output_low(CALOR4); 
02AA:  BSF    03.5
02AB:  BCF    06.0
02AC:  BCF    03.5
02AD:  BCF    06.0
....................       break; 
02AE:  GOTO   2E1
....................  
....................    case 3: 
....................       output_low(CALOR1); 
02AF:  BSF    03.5
02B0:  BCF    06.1
02B1:  BCF    03.5
02B2:  BCF    06.1
....................       output_high(CALOR2); 
02B3:  BSF    03.5
02B4:  BCF    06.2
02B5:  BCF    03.5
02B6:  BSF    06.2
....................       output_high(CALOR3); 
02B7:  BSF    03.5
02B8:  BCF    06.3
02B9:  BCF    03.5
02BA:  BSF    06.3
....................       output_high(CALOR4); 
02BB:  BSF    03.5
02BC:  BCF    06.0
02BD:  BCF    03.5
02BE:  BSF    06.0
....................       break; 
02BF:  GOTO   2E1
....................  
....................    case 4: 
....................       output_high(CALOR1); 
02C0:  BSF    03.5
02C1:  BCF    06.1
02C2:  BCF    03.5
02C3:  BSF    06.1
....................       output_high(CALOR2); 
02C4:  BSF    03.5
02C5:  BCF    06.2
02C6:  BCF    03.5
02C7:  BSF    06.2
....................       output_high(CALOR3); 
02C8:  BSF    03.5
02C9:  BCF    06.3
02CA:  BCF    03.5
02CB:  BSF    06.3
....................       output_high(CALOR4); 
02CC:  BSF    03.5
02CD:  BCF    06.0
02CE:  BCF    03.5
02CF:  BSF    06.0
....................       break; 
02D0:  GOTO   2E1
.................... /* 
....................    case 5: 
....................       output_low(CALOR1); 
....................       output_high(CALOR1B); 
....................       output_low(CALOR2); 
....................       output_high(CALOR4); 
....................       break; 
....................  
....................    case 6: 
....................       output_low(CALOR1); 
....................       output_low(CALOR1B); 
....................       output_high(CALOR2); 
....................       output_high(CALOR4); 
....................       break; 
....................  
....................    case 7: 
....................       output_low(CALOR1); 
....................       output_high(CALOR1B); 
....................       output_high(CALOR2); 
....................       output_high(CALOR4); 
....................       break; 
....................  
....................    case 8: 
....................       output_high(CALOR1); 
....................       output_high(CALOR1B); 
....................       output_high(CALOR2); 
....................       output_high(CALOR4); 
....................       break; 
.................... */ 
....................    defalut: 
....................       output_low(CALOR1); 
02D1:  BSF    03.5
02D2:  BCF    06.1
02D3:  BCF    03.5
02D4:  BCF    06.1
....................       output_low(CALOR2); 
02D5:  BSF    03.5
02D6:  BCF    06.2
02D7:  BCF    03.5
02D8:  BCF    06.2
....................       output_low(CALOR3); 
02D9:  BSF    03.5
02DA:  BCF    06.3
02DB:  BCF    03.5
02DC:  BCF    06.3
....................       output_low(CALOR4); 
02DD:  BSF    03.5
02DE:  BCF    06.0
02DF:  BCF    03.5
02E0:  BCF    06.0
....................       break; 
.................... } 
....................  PotActual = RR; 
02E1:  MOVF   40,W
02E2:  MOVWF  36
....................  restart_wdt(); // Reiniciamos el perro 
02E3:  CLRWDT
.................... } 
02E4:  RETURN
....................  
.................... void Tiempo(){ 
.................... ds1307_get_time(hrs,min,sec); 
.................... delay_ms(2); 
*
0ED4:  MOVLW  02
0ED5:  BCF    03.5
0ED6:  MOVWF  4C
0ED7:  BCF    0A.3
0ED8:  CALL   090
0ED9:  BSF    0A.3
.................... } 
0EDA:  BCF    0A.3
0EDB:  BSF    0A.4
0EDC:  GOTO   28E (RETURN)
....................  
.................... void Teclado(){ 
....................  
.................... restart_wdt(); 
*
033B:  CLRWDT
.................... if (input(ARRIBA)==0 && input(ABAJO)==0 && input(PROX)==0) Rebote = false; // Soltamos las teclas 
033C:  BSF    20.0
033D:  MOVF   20,W
033E:  BSF    03.5
033F:  MOVWF  07
0340:  BCF    03.5
0341:  BTFSC  07.0
0342:  GOTO   351
0343:  BSF    20.1
0344:  MOVF   20,W
0345:  BSF    03.5
0346:  MOVWF  07
0347:  BCF    03.5
0348:  BTFSC  07.1
0349:  GOTO   351
034A:  BSF    20.2
034B:  MOVF   20,W
034C:  BSF    03.5
034D:  MOVWF  07
034E:  BCF    03.5
034F:  BTFSS  07.2
0350:  BCF    24.0
.................... restart_wdt(); // Reiniciamos el perro 
0351:  CLRWDT
.................... if (Rebote == false){ // Tomamos el comando ya que el antirebote nos dice que esta ok 
0352:  BTFSC  24.0
0353:  GOTO   5BD
....................  
....................   if (input(ARRIBA)==1 && input(ABAJO)==1){ // Reseteamos el estado critico 
0354:  BSF    20.0
0355:  MOVF   20,W
0356:  BSF    03.5
0357:  MOVWF  07
0358:  BCF    03.5
0359:  BTFSS  07.0
035A:  GOTO   364
035B:  BSF    20.1
035C:  MOVF   20,W
035D:  BSF    03.5
035E:  MOVWF  07
035F:  BCF    03.5
0360:  BTFSS  07.1
0361:  GOTO   364
....................   Rebote = True; 
0362:  BSF    24.0
....................   EstadoCritico = 0; 
0363:  CLRF   37
....................   } 
....................  
....................   if (input(PROX)==1){ 
0364:  BSF    20.2
0365:  MOVF   20,W
0366:  BSF    03.5
0367:  MOVWF  07
0368:  BCF    03.5
0369:  BTFSS  07.2
036A:  GOTO   374
....................   Rebote = True; 
036B:  BSF    24.0
....................   Menu = Menu + 1; 
036C:  MOVLW  01
036D:  ADDWF  25,F
....................   if (Menu == 9) Menu = 1;  
036E:  MOVF   25,W
036F:  SUBLW  09
0370:  BTFSS  03.2
0371:  GOTO   374
0372:  MOVLW  01
0373:  MOVWF  25
....................   } 
....................  
.................... switch (Menu){ 
0374:  MOVLW  01
0375:  SUBWF  25,W
0376:  ADDLW  F8
0377:  BTFSC  03.0
0378:  GOTO   5BD
0379:  ADDLW  08
037A:  GOTO   5BE
....................    case 3: 
....................       if (input(ARRIBA)==1){ 
037B:  BSF    20.0
037C:  MOVF   20,W
037D:  BSF    03.5
037E:  MOVWF  07
037F:  BCF    03.5
0380:  BTFSS  07.0
0381:  GOTO   3A7
....................       Rebote = True; 
0382:  BSF    24.0
....................       Termostato = Termostato + 1; 
0383:  MOVLW  01
0384:  ADDWF  30,F
....................       if (Termostato == 18) Termostato = 17; 
0385:  MOVF   30,W
0386:  SUBLW  12
0387:  BTFSS  03.2
0388:  GOTO   38B
0389:  MOVLW  11
038A:  MOVWF  30
....................       write_eeprom(TERMOSTAT,Termostato); 
038B:  MOVF   0B,W
038C:  MOVWF  77
038D:  BCF    0B.7
038E:  MOVLW  1A
038F:  BSF    03.6
0390:  MOVWF  0D
0391:  BCF    03.6
0392:  MOVF   30,W
0393:  BSF    03.6
0394:  MOVWF  0C
0395:  BSF    03.5
0396:  BCF    0C.7
0397:  BSF    0C.2
0398:  MOVLW  55
0399:  MOVWF  0D
039A:  MOVLW  AA
039B:  MOVWF  0D
039C:  BSF    0C.1
039D:  BTFSC  0C.1
039E:  GOTO   39D
039F:  BCF    0C.2
03A0:  MOVF   77,W
03A1:  BCF    03.5
03A2:  BCF    03.6
03A3:  IORWF  0B,F
....................       delay_ms(5); 
03A4:  MOVLW  05
03A5:  MOVWF  4C
03A6:  CALL   090
....................       } 
....................        
....................       if (input(ABAJO)==1){ 
03A7:  BSF    20.1
03A8:  MOVF   20,W
03A9:  BSF    03.5
03AA:  MOVWF  07
03AB:  BCF    03.5
03AC:  BTFSS  07.1
03AD:  GOTO   3D3
....................       Rebote = True; 
03AE:  BSF    24.0
....................       Termostato = Termostato - 1; 
03AF:  MOVLW  01
03B0:  SUBWF  30,F
....................       if (Termostato == 7) Termostato = 8; // El 7 es APAGADO (Termostato x 5 da la temperatura en °C) 
03B1:  MOVF   30,W
03B2:  SUBLW  07
03B3:  BTFSS  03.2
03B4:  GOTO   3B7
03B5:  MOVLW  08
03B6:  MOVWF  30
....................       write_eeprom(TERMOSTAT,Termostato); 
03B7:  MOVF   0B,W
03B8:  MOVWF  77
03B9:  BCF    0B.7
03BA:  MOVLW  1A
03BB:  BSF    03.6
03BC:  MOVWF  0D
03BD:  BCF    03.6
03BE:  MOVF   30,W
03BF:  BSF    03.6
03C0:  MOVWF  0C
03C1:  BSF    03.5
03C2:  BCF    0C.7
03C3:  BSF    0C.2
03C4:  MOVLW  55
03C5:  MOVWF  0D
03C6:  MOVLW  AA
03C7:  MOVWF  0D
03C8:  BSF    0C.1
03C9:  BTFSC  0C.1
03CA:  GOTO   3C9
03CB:  BCF    0C.2
03CC:  MOVF   77,W
03CD:  BCF    03.5
03CE:  BCF    03.6
03CF:  IORWF  0B,F
....................       delay_ms(5); 
03D0:  MOVLW  05
03D1:  MOVWF  4C
03D2:  CALL   090
....................       } 
....................    break; 
03D3:  GOTO   5BD
....................  
....................    case 4: 
....................       if (input(ARRIBA)==1){ 
03D4:  BSF    20.0
03D5:  MOVF   20,W
03D6:  BSF    03.5
03D7:  MOVWF  07
03D8:  BCF    03.5
03D9:  BTFSS  07.0
03DA:  GOTO   3FE
....................       Rebote = True; 
03DB:  BSF    24.0
....................       HsOn = HsOn + 1; 
03DC:  MOVLW  01
03DD:  ADDWF  31,F
....................       if (HsOn == 49) HsOn = 0; 
03DE:  MOVF   31,W
03DF:  SUBLW  31
03E0:  BTFSC  03.2
03E1:  CLRF   31
....................       write_eeprom(HSENCENDIDO,HsOn); 
03E2:  MOVF   0B,W
03E3:  MOVWF  77
03E4:  BCF    0B.7
03E5:  MOVLW  14
03E6:  BSF    03.6
03E7:  MOVWF  0D
03E8:  BCF    03.6
03E9:  MOVF   31,W
03EA:  BSF    03.6
03EB:  MOVWF  0C
03EC:  BSF    03.5
03ED:  BCF    0C.7
03EE:  BSF    0C.2
03EF:  MOVLW  55
03F0:  MOVWF  0D
03F1:  MOVLW  AA
03F2:  MOVWF  0D
03F3:  BSF    0C.1
03F4:  BTFSC  0C.1
03F5:  GOTO   3F4
03F6:  BCF    0C.2
03F7:  MOVF   77,W
03F8:  BCF    03.5
03F9:  BCF    03.6
03FA:  IORWF  0B,F
....................       delay_ms(5); 
03FB:  MOVLW  05
03FC:  MOVWF  4C
03FD:  CALL   090
....................       } 
....................        
....................       if (input(ABAJO)==1){ 
03FE:  BSF    20.1
03FF:  MOVF   20,W
0400:  BSF    03.5
0401:  MOVWF  07
0402:  BCF    03.5
0403:  BTFSS  07.1
0404:  GOTO   428
....................       Rebote = True; 
0405:  BSF    24.0
....................       HsOn = HsOn - 1; 
0406:  MOVLW  01
0407:  SUBWF  31,F
....................       if (HsOn == 255) HsOn = 48; 
0408:  INCFSZ 31,W
0409:  GOTO   40C
040A:  MOVLW  30
040B:  MOVWF  31
....................       write_eeprom(HSENCENDIDO,HsOn); 
040C:  MOVF   0B,W
040D:  MOVWF  77
040E:  BCF    0B.7
040F:  MOVLW  14
0410:  BSF    03.6
0411:  MOVWF  0D
0412:  BCF    03.6
0413:  MOVF   31,W
0414:  BSF    03.6
0415:  MOVWF  0C
0416:  BSF    03.5
0417:  BCF    0C.7
0418:  BSF    0C.2
0419:  MOVLW  55
041A:  MOVWF  0D
041B:  MOVLW  AA
041C:  MOVWF  0D
041D:  BSF    0C.1
041E:  BTFSC  0C.1
041F:  GOTO   41E
0420:  BCF    0C.2
0421:  MOVF   77,W
0422:  BCF    03.5
0423:  BCF    03.6
0424:  IORWF  0B,F
....................       delay_ms(5); 
0425:  MOVLW  05
0426:  MOVWF  4C
0427:  CALL   090
....................       } 
....................    break; 
0428:  GOTO   5BD
....................  
....................    case 5: 
....................       if (input(ARRIBA)==1){ 
0429:  BSF    20.0
042A:  MOVF   20,W
042B:  BSF    03.5
042C:  MOVWF  07
042D:  BCF    03.5
042E:  BTFSS  07.0
042F:  GOTO   453
....................       Rebote = True; 
0430:  BSF    24.0
....................       HsOff = HsOff + 1; 
0431:  MOVLW  01
0432:  ADDWF  32,F
....................       if (HsOff == 49) HsOff = 0; 
0433:  MOVF   32,W
0434:  SUBLW  31
0435:  BTFSC  03.2
0436:  CLRF   32
....................       write_eeprom(HSAPAGADO,HsOff); 
0437:  MOVF   0B,W
0438:  MOVWF  77
0439:  BCF    0B.7
043A:  MOVLW  16
043B:  BSF    03.6
043C:  MOVWF  0D
043D:  BCF    03.6
043E:  MOVF   32,W
043F:  BSF    03.6
0440:  MOVWF  0C
0441:  BSF    03.5
0442:  BCF    0C.7
0443:  BSF    0C.2
0444:  MOVLW  55
0445:  MOVWF  0D
0446:  MOVLW  AA
0447:  MOVWF  0D
0448:  BSF    0C.1
0449:  BTFSC  0C.1
044A:  GOTO   449
044B:  BCF    0C.2
044C:  MOVF   77,W
044D:  BCF    03.5
044E:  BCF    03.6
044F:  IORWF  0B,F
....................       delay_ms(5); 
0450:  MOVLW  05
0451:  MOVWF  4C
0452:  CALL   090
....................       } 
....................        
....................       if (input(ABAJO)==1){ 
0453:  BSF    20.1
0454:  MOVF   20,W
0455:  BSF    03.5
0456:  MOVWF  07
0457:  BCF    03.5
0458:  BTFSS  07.1
0459:  GOTO   47D
....................       Rebote = True; 
045A:  BSF    24.0
....................       HsOff = HsOff - 1; 
045B:  MOVLW  01
045C:  SUBWF  32,F
....................       if (HsOff == 255) HsOff = 48; 
045D:  INCFSZ 32,W
045E:  GOTO   461
045F:  MOVLW  30
0460:  MOVWF  32
....................       write_eeprom(HSAPAGADO,HsOff); 
0461:  MOVF   0B,W
0462:  MOVWF  77
0463:  BCF    0B.7
0464:  MOVLW  16
0465:  BSF    03.6
0466:  MOVWF  0D
0467:  BCF    03.6
0468:  MOVF   32,W
0469:  BSF    03.6
046A:  MOVWF  0C
046B:  BSF    03.5
046C:  BCF    0C.7
046D:  BSF    0C.2
046E:  MOVLW  55
046F:  MOVWF  0D
0470:  MOVLW  AA
0471:  MOVWF  0D
0472:  BSF    0C.1
0473:  BTFSC  0C.1
0474:  GOTO   473
0475:  BCF    0C.2
0476:  MOVF   77,W
0477:  BCF    03.5
0478:  BCF    03.6
0479:  IORWF  0B,F
....................       delay_ms(5); 
047A:  MOVLW  05
047B:  MOVWF  4C
047C:  CALL   090
....................       } 
....................    break; 
047D:  GOTO   5BD
....................  
....................    case 2: 
....................       if (input(ARRIBA)==1){ 
047E:  BSF    20.0
047F:  MOVF   20,W
0480:  BSF    03.5
0481:  MOVWF  07
0482:  BCF    03.5
0483:  BTFSS  07.0
0484:  GOTO   4AA
....................       Rebote = True; 
0485:  BSF    24.0
....................       MaxPower = MaxPower + 1; 
0486:  MOVLW  01
0487:  ADDWF  33,F
....................       if (MaxPower == 5) MaxPower = 4; 
0488:  MOVF   33,W
0489:  SUBLW  05
048A:  BTFSS  03.2
048B:  GOTO   48E
048C:  MOVLW  04
048D:  MOVWF  33
....................       write_eeprom(POTMAX,MaxPower); 
048E:  MOVF   0B,W
048F:  MOVWF  77
0490:  BCF    0B.7
0491:  MOVLW  18
0492:  BSF    03.6
0493:  MOVWF  0D
0494:  BCF    03.6
0495:  MOVF   33,W
0496:  BSF    03.6
0497:  MOVWF  0C
0498:  BSF    03.5
0499:  BCF    0C.7
049A:  BSF    0C.2
049B:  MOVLW  55
049C:  MOVWF  0D
049D:  MOVLW  AA
049E:  MOVWF  0D
049F:  BSF    0C.1
04A0:  BTFSC  0C.1
04A1:  GOTO   4A0
04A2:  BCF    0C.2
04A3:  MOVF   77,W
04A4:  BCF    03.5
04A5:  BCF    03.6
04A6:  IORWF  0B,F
....................       delay_ms(5); 
04A7:  MOVLW  05
04A8:  MOVWF  4C
04A9:  CALL   090
....................       } 
....................        
....................       if (input(ABAJO)==1){ 
04AA:  BSF    20.1
04AB:  MOVF   20,W
04AC:  BSF    03.5
04AD:  MOVWF  07
04AE:  BCF    03.5
04AF:  BTFSS  07.1
04B0:  GOTO   4D5
....................       Rebote = True; 
04B1:  BSF    24.0
....................       MaxPower = MaxPower - 1; 
04B2:  MOVLW  01
04B3:  SUBWF  33,F
....................       if (MaxPower == 0) MaxPower = 1; 
04B4:  MOVF   33,F
04B5:  BTFSS  03.2
04B6:  GOTO   4B9
04B7:  MOVLW  01
04B8:  MOVWF  33
....................       write_eeprom(POTMAX,MaxPower); 
04B9:  MOVF   0B,W
04BA:  MOVWF  77
04BB:  BCF    0B.7
04BC:  MOVLW  18
04BD:  BSF    03.6
04BE:  MOVWF  0D
04BF:  BCF    03.6
04C0:  MOVF   33,W
04C1:  BSF    03.6
04C2:  MOVWF  0C
04C3:  BSF    03.5
04C4:  BCF    0C.7
04C5:  BSF    0C.2
04C6:  MOVLW  55
04C7:  MOVWF  0D
04C8:  MOVLW  AA
04C9:  MOVWF  0D
04CA:  BSF    0C.1
04CB:  BTFSC  0C.1
04CC:  GOTO   4CB
04CD:  BCF    0C.2
04CE:  MOVF   77,W
04CF:  BCF    03.5
04D0:  BCF    03.6
04D1:  IORWF  0B,F
....................       delay_ms(5); 
04D2:  MOVLW  05
04D3:  MOVWF  4C
04D4:  CALL   090
....................       } 
....................    break; 
04D5:  GOTO   5BD
....................  
....................    case 1: 
....................       if (input(ARRIBA)==1) output_high(BBA); 
04D6:  BSF    20.0
04D7:  MOVF   20,W
04D8:  BSF    03.5
04D9:  MOVWF  07
04DA:  BCF    03.5
04DB:  BTFSS  07.0
04DC:  GOTO   4E2
04DD:  BSF    03.5
04DE:  BCF    08.1
04DF:  BCF    03.5
04E0:  BSF    08.1
....................       else output_low(BBA); 
04E1:  GOTO   4E6
04E2:  BSF    03.5
04E3:  BCF    08.1
04E4:  BCF    03.5
04E5:  BCF    08.1
....................        
....................       if (input(ABAJO)==1) output_high(VALVE); 
04E6:  BSF    20.1
04E7:  MOVF   20,W
04E8:  BSF    03.5
04E9:  MOVWF  07
04EA:  BCF    03.5
04EB:  BTFSS  07.1
04EC:  GOTO   4F2
04ED:  BSF    03.5
04EE:  BCF    08.2
04EF:  BCF    03.5
04F0:  BSF    08.2
....................       else output_low(VALVE); 
04F1:  GOTO   4F6
04F2:  BSF    03.5
04F3:  BCF    08.2
04F4:  BCF    03.5
04F5:  BCF    08.2
....................    break; 
04F6:  GOTO   5BD
....................  
....................   case 6: 
....................       ds1307_get_time(HsConfig,MinConfig,sec); 
....................       delay_ms(2); 
*
0565:  MOVLW  02
0566:  BCF    03.5
0567:  MOVWF  4C
0568:  CALL   090
....................       Menu = 7; 
0569:  MOVLW  07
056A:  MOVWF  25
....................   break; 
056B:  GOTO   5BD
....................  
....................   case 7: 
....................       if (input(ARRIBA)==1){ 
056C:  BSF    20.0
056D:  MOVF   20,W
056E:  BSF    03.5
056F:  MOVWF  07
0570:  BCF    03.5
0571:  BTFSS  07.0
0572:  GOTO   580
....................       Rebote = True; 
0573:  BSF    24.0
....................       HsConfig = HsConfig + 1; 
0574:  MOVLW  01
0575:  ADDWF  34,F
....................       if (HsConfig > 23) HsConfig = 0; 
0576:  MOVF   34,W
0577:  SUBLW  17
0578:  BTFSS  03.0
0579:  CLRF   34
....................       ds1307_set_time(HsConfig, MinConfig, 0); 
057A:  MOVF   34,W
057B:  MOVWF  3E
057C:  MOVF   35,W
057D:  MOVWF  3F
057E:  CLRF   40
057F:  CALL   2EE
....................       } 
....................        
....................       if (input(ABAJO)==1){ 
0580:  BSF    20.1
0581:  MOVF   20,W
0582:  BSF    03.5
0583:  MOVWF  07
0584:  BCF    03.5
0585:  BTFSS  07.1
0586:  GOTO   594
....................       Rebote = True; 
0587:  BSF    24.0
....................       HsConfig = HsConfig - 1; 
0588:  MOVLW  01
0589:  SUBWF  34,F
....................       if (HsConfig == 255) HsConfig = 23; 
058A:  INCFSZ 34,W
058B:  GOTO   58E
058C:  MOVLW  17
058D:  MOVWF  34
....................       ds1307_set_time(HsConfig, MinConfig, 0); 
058E:  MOVF   34,W
058F:  MOVWF  3E
0590:  MOVF   35,W
0591:  MOVWF  3F
0592:  CLRF   40
0593:  CALL   2EE
....................       } 
....................    break; 
0594:  GOTO   5BD
....................     
....................   case 8: 
....................       if (input(ARRIBA)==1){ 
0595:  BSF    20.0
0596:  MOVF   20,W
0597:  BSF    03.5
0598:  MOVWF  07
0599:  BCF    03.5
059A:  BTFSS  07.0
059B:  GOTO   5A9
....................       Rebote = True; 
059C:  BSF    24.0
....................       MinConfig = MinConfig + 1; 
059D:  MOVLW  01
059E:  ADDWF  35,F
....................       if (MinConfig > 59) MinConfig = 0; 
059F:  MOVF   35,W
05A0:  SUBLW  3B
05A1:  BTFSS  03.0
05A2:  CLRF   35
....................       ds1307_set_time(HsConfig, MinConfig, 0); 
05A3:  MOVF   34,W
05A4:  MOVWF  3E
05A5:  MOVF   35,W
05A6:  MOVWF  3F
05A7:  CLRF   40
05A8:  CALL   2EE
....................       } 
....................        
....................       if (input(ABAJO)==1){ 
05A9:  BSF    20.1
05AA:  MOVF   20,W
05AB:  BSF    03.5
05AC:  MOVWF  07
05AD:  BCF    03.5
05AE:  BTFSS  07.1
05AF:  GOTO   5BD
....................       Rebote = True; 
05B0:  BSF    24.0
....................       MinConfig = MinConfig - 1; 
05B1:  MOVLW  01
05B2:  SUBWF  35,F
....................       if (MinConfig == 255) MinConfig = 59; 
05B3:  INCFSZ 35,W
05B4:  GOTO   5B7
05B5:  MOVLW  3B
05B6:  MOVWF  35
....................       ds1307_set_time(HsConfig, MinConfig, 0); 
05B7:  MOVF   34,W
05B8:  MOVWF  3E
05B9:  MOVF   35,W
05BA:  MOVWF  3F
05BB:  CLRF   40
05BC:  CALL   2EE
....................       } 
....................    break; 
.................... } 
....................  
.................... }//rebote falso 
.................... } //fn 
05BD:  RETURN
....................  
....................  
.................... void Pantalla(){ 
....................    lcd_gotoxy(16,1); 
*
0A7D:  MOVLW  10
0A7E:  MOVWF  4C
0A7F:  MOVLW  01
0A80:  MOVWF  4D
0A81:  BCF    0A.3
0A82:  CALL   1F5
0A83:  BSF    0A.3
....................    if (Llenar) printf(lcd_putc,"#"); 
0A84:  BTFSS  24.1
0A85:  GOTO   28C
0A86:  MOVLW  23
0A87:  MOVWF  4B
0A88:  BCF    0A.3
0A89:  CALL   207
0A8A:  BSF    0A.3
....................    else printf(lcd_putc," "); 
0A8B:  GOTO   291
0A8C:  MOVLW  20
0A8D:  MOVWF  4B
0A8E:  BCF    0A.3
0A8F:  CALL   207
0A90:  BSF    0A.3
....................    lcd_gotoxy(1,1); 
0A91:  MOVLW  01
0A92:  MOVWF  4C
0A93:  MOVWF  4D
0A94:  BCF    0A.3
0A95:  CALL   1F5
0A96:  BSF    0A.3
....................    if (EstadoCritico == 0) { 
0A97:  MOVF   37,F
0A98:  BTFSS  03.2
0A99:  GOTO   311
....................          if (bit_test(ii,0)) printf(lcd_putc,"TO:%4.1f%cC %02d:%02d", TempOut,223,hrs,min); 
0A9A:  BTFSS  38.0
0A9B:  GOTO   2D7
0A9C:  MOVLW  54
0A9D:  MOVWF  4B
0A9E:  BCF    0A.3
0A9F:  CALL   207
0AA0:  BSF    0A.3
0AA1:  MOVLW  4F
0AA2:  MOVWF  4B
0AA3:  BCF    0A.3
0AA4:  CALL   207
0AA5:  BSF    0A.3
0AA6:  MOVLW  3A
0AA7:  MOVWF  4B
0AA8:  BCF    0A.3
0AA9:  CALL   207
0AAA:  BSF    0A.3
0AAB:  MOVLW  03
0AAC:  MOVWF  04
0AAD:  MOVF   2D,W
0AAE:  MOVWF  41
0AAF:  MOVF   2C,W
0AB0:  MOVWF  40
0AB1:  MOVF   2B,W
0AB2:  MOVWF  3F
0AB3:  MOVF   2A,W
0AB4:  MOVWF  3E
0AB5:  MOVLW  01
0AB6:  MOVWF  42
0AB7:  CALL   000
0AB8:  MOVLW  DF
0AB9:  MOVWF  4B
0ABA:  BCF    0A.3
0ABB:  CALL   207
0ABC:  BSF    0A.3
0ABD:  MOVLW  43
0ABE:  MOVWF  4B
0ABF:  BCF    0A.3
0AC0:  CALL   207
0AC1:  BSF    0A.3
0AC2:  MOVLW  20
0AC3:  MOVWF  4B
0AC4:  BCF    0A.3
0AC5:  CALL   207
0AC6:  BSF    0A.3
0AC7:  MOVF   23,W
0AC8:  MOVWF  40
0AC9:  MOVLW  01
0ACA:  MOVWF  41
0ACB:  CALL   15F
0ACC:  MOVLW  3A
0ACD:  MOVWF  4B
0ACE:  BCF    0A.3
0ACF:  CALL   207
0AD0:  BSF    0A.3
0AD1:  MOVF   22,W
0AD2:  MOVWF  40
0AD3:  MOVLW  01
0AD4:  MOVWF  41
0AD5:  CALL   15F
....................          else printf(lcd_putc,"TI:%4.1f%cC %02d:%02d", TempIn,223,hrs,min); 
0AD6:  GOTO   311
0AD7:  MOVLW  54
0AD8:  MOVWF  4B
0AD9:  BCF    0A.3
0ADA:  CALL   207
0ADB:  BSF    0A.3
0ADC:  MOVLW  49
0ADD:  MOVWF  4B
0ADE:  BCF    0A.3
0ADF:  CALL   207
0AE0:  BSF    0A.3
0AE1:  MOVLW  3A
0AE2:  MOVWF  4B
0AE3:  BCF    0A.3
0AE4:  CALL   207
0AE5:  BSF    0A.3
0AE6:  MOVLW  03
0AE7:  MOVWF  04
0AE8:  MOVF   29,W
0AE9:  MOVWF  41
0AEA:  MOVF   28,W
0AEB:  MOVWF  40
0AEC:  MOVF   27,W
0AED:  MOVWF  3F
0AEE:  MOVF   26,W
0AEF:  MOVWF  3E
0AF0:  MOVLW  01
0AF1:  MOVWF  42
0AF2:  CALL   000
0AF3:  MOVLW  DF
0AF4:  MOVWF  4B
0AF5:  BCF    0A.3
0AF6:  CALL   207
0AF7:  BSF    0A.3
0AF8:  MOVLW  43
0AF9:  MOVWF  4B
0AFA:  BCF    0A.3
0AFB:  CALL   207
0AFC:  BSF    0A.3
0AFD:  MOVLW  20
0AFE:  MOVWF  4B
0AFF:  BCF    0A.3
0B00:  CALL   207
0B01:  BSF    0A.3
0B02:  MOVF   23,W
0B03:  MOVWF  40
0B04:  MOVLW  01
0B05:  MOVWF  41
0B06:  CALL   15F
0B07:  MOVLW  3A
0B08:  MOVWF  4B
0B09:  BCF    0A.3
0B0A:  CALL   207
0B0B:  BSF    0A.3
0B0C:  MOVF   22,W
0B0D:  MOVWF  40
0B0E:  MOVLW  01
0B0F:  MOVWF  41
0B10:  CALL   15F
....................    } 
....................    if (EstadoCritico == 1) printf(lcd_putc,"EXCESO DE TEMPER");  
0B11:  DECFSZ 37,W
0B12:  GOTO   31C
0B13:  MOVLW  0D
0B14:  BSF    03.6
0B15:  MOVWF  0D
0B16:  MOVLW  00
0B17:  MOVWF  0F
0B18:  BCF    0A.3
0B19:  BCF    03.6
0B1A:  CALL   22B
0B1B:  BSF    0A.3
....................    if (EstadoCritico == 2) printf(lcd_putc,"BAJO NIVEL AGUA ");  
0B1C:  MOVF   37,W
0B1D:  SUBLW  02
0B1E:  BTFSS  03.2
0B1F:  GOTO   329
0B20:  MOVLW  16
0B21:  BSF    03.6
0B22:  MOVWF  0D
0B23:  MOVLW  00
0B24:  MOVWF  0F
0B25:  BCF    0A.3
0B26:  BCF    03.6
0B27:  CALL   22B
0B28:  BSF    0A.3
....................    if (EstadoCritico == 3) printf(lcd_putc,"FALLA DE SENSOR "); 
0B29:  MOVF   37,W
0B2A:  SUBLW  03
0B2B:  BTFSS  03.2
0B2C:  GOTO   336
0B2D:  MOVLW  1F
0B2E:  BSF    03.6
0B2F:  MOVWF  0D
0B30:  MOVLW  00
0B31:  MOVWF  0F
0B32:  BCF    0A.3
0B33:  BCF    03.6
0B34:  CALL   22B
0B35:  BSF    0A.3
....................    restart_wdt(); // Reiniciamos el perro 
0B36:  CLRWDT
....................  
.................... switch (Menu){ 
0B37:  MOVLW  01
0B38:  SUBWF  25,W
0B39:  ADDLW  F8
0B3A:  BTFSC  03.0
0B3B:  GOTO   48F
0B3C:  ADDLW  08
0B3D:  GOTO   490
....................    case 3: 
....................    lcd_gotoxy(1,2); 
0B3E:  MOVLW  01
0B3F:  MOVWF  4C
0B40:  MOVLW  02
0B41:  MOVWF  4D
0B42:  BCF    0A.3
0B43:  CALL   1F5
0B44:  BSF    0A.3
....................    if (Termostato == 7) printf(lcd_putc,"Ter: OFF P: %d kW",(PotActual * 2));  
0B45:  MOVF   30,W
0B46:  SUBLW  07
0B47:  BTFSS  03.2
0B48:  GOTO   36B
0B49:  BCF    03.0
0B4A:  RLF    36,W
0B4B:  MOVWF  3E
0B4C:  MOVLW  28
0B4D:  BSF    03.6
0B4E:  MOVWF  0D
0B4F:  MOVLW  00
0B50:  MOVWF  0F
0B51:  BCF    03.0
0B52:  MOVLW  0C
0B53:  BCF    03.6
0B54:  MOVWF  40
0B55:  CALL   1C2
0B56:  MOVF   3E,W
0B57:  MOVWF  40
0B58:  MOVLW  18
0B59:  MOVWF  41
0B5A:  CALL   21A
0B5B:  MOVLW  20
0B5C:  MOVWF  4B
0B5D:  BCF    0A.3
0B5E:  CALL   207
0B5F:  BSF    0A.3
0B60:  MOVLW  6B
0B61:  MOVWF  4B
0B62:  BCF    0A.3
0B63:  CALL   207
0B64:  BSF    0A.3
0B65:  MOVLW  57
0B66:  MOVWF  4B
0B67:  BCF    0A.3
0B68:  CALL   207
0B69:  BSF    0A.3
....................    else printf(lcd_putc,"Ter:%2d%cC P: %d kW", Termostato*5,223,(PotActual * 2));  
0B6A:  GOTO   3A9
0B6B:  MOVF   30,W
0B6C:  MOVWF  41
0B6D:  MOVLW  05
0B6E:  MOVWF  42
0B6F:  BCF    0A.3
0B70:  CALL   7B5
0B71:  BSF    0A.3
0B72:  MOVF   78,W
0B73:  MOVWF  3E
0B74:  BCF    03.0
0B75:  RLF    36,W
0B76:  MOVWF  3F
0B77:  MOVLW  31
0B78:  BSF    03.6
0B79:  MOVWF  0D
0B7A:  MOVLW  00
0B7B:  MOVWF  0F
0B7C:  BCF    03.0
0B7D:  MOVLW  04
0B7E:  BCF    03.6
0B7F:  MOVWF  40
0B80:  CALL   1C2
0B81:  MOVF   3E,W
0B82:  MOVWF  40
0B83:  MOVLW  11
0B84:  MOVWF  41
0B85:  CALL   21A
0B86:  MOVLW  DF
0B87:  MOVWF  4B
0B88:  BCF    0A.3
0B89:  CALL   207
0B8A:  BSF    0A.3
0B8B:  MOVLW  35
0B8C:  BSF    03.6
0B8D:  MOVWF  0D
0B8E:  MOVLW  00
0B8F:  MOVWF  0F
0B90:  BSF    03.0
0B91:  MOVLW  05
0B92:  BCF    03.6
0B93:  MOVWF  40
0B94:  CALL   1C2
0B95:  MOVF   3F,W
0B96:  MOVWF  40
0B97:  MOVLW  18
0B98:  MOVWF  41
0B99:  CALL   21A
0B9A:  MOVLW  20
0B9B:  MOVWF  4B
0B9C:  BCF    0A.3
0B9D:  CALL   207
0B9E:  BSF    0A.3
0B9F:  MOVLW  6B
0BA0:  MOVWF  4B
0BA1:  BCF    0A.3
0BA2:  CALL   207
0BA3:  BSF    0A.3
0BA4:  MOVLW  57
0BA5:  MOVWF  4B
0BA6:  BCF    0A.3
0BA7:  CALL   207
0BA8:  BSF    0A.3
....................    break; 
0BA9:  GOTO   48F
....................  
....................    case 4: 
....................    lcd_gotoxy(1,2);  
0BAA:  MOVLW  01
0BAB:  MOVWF  4C
0BAC:  MOVLW  02
0BAD:  MOVWF  4D
0BAE:  BCF    0A.3
0BAF:  CALL   1F5
0BB0:  BSF    0A.3
....................    if (HsOn == 48 ) printf(lcd_putc,"Hs Encend: OFF  "); 
0BB1:  MOVF   31,W
0BB2:  SUBLW  30
0BB3:  BTFSS  03.2
0BB4:  GOTO   3BF
0BB5:  MOVLW  3B
0BB6:  BSF    03.6
0BB7:  MOVWF  0D
0BB8:  MOVLW  00
0BB9:  MOVWF  0F
0BBA:  BCF    0A.3
0BBB:  BCF    03.6
0BBC:  CALL   22B
0BBD:  BSF    0A.3
....................    else printf(lcd_putc,"Hs Encend: %02d:%02d", HsOn/2,(HsOn%2)*30);  
0BBE:  GOTO   3E6
0BBF:  BCF    03.0
0BC0:  RRF    31,W
0BC1:  MOVWF  3E
0BC2:  MOVF   31,W
0BC3:  ANDLW  01
0BC4:  MOVWF  40
0BC5:  MOVWF  41
0BC6:  MOVLW  1E
0BC7:  MOVWF  42
0BC8:  BCF    0A.3
0BC9:  CALL   7B5
0BCA:  BSF    0A.3
0BCB:  MOVF   78,W
0BCC:  MOVWF  3F
0BCD:  MOVLW  44
0BCE:  BSF    03.6
0BCF:  MOVWF  0D
0BD0:  MOVLW  00
0BD1:  MOVWF  0F
0BD2:  BCF    03.0
0BD3:  MOVLW  0B
0BD4:  BCF    03.6
0BD5:  MOVWF  40
0BD6:  CALL   1C2
0BD7:  MOVF   3E,W
0BD8:  MOVWF  40
0BD9:  MOVLW  01
0BDA:  MOVWF  41
0BDB:  CALL   15F
0BDC:  MOVLW  3A
0BDD:  MOVWF  4B
0BDE:  BCF    0A.3
0BDF:  CALL   207
0BE0:  BSF    0A.3
0BE1:  MOVF   3F,W
0BE2:  MOVWF  40
0BE3:  MOVLW  01
0BE4:  MOVWF  41
0BE5:  CALL   15F
....................    break; 
0BE6:  GOTO   48F
....................  
....................    case 5: 
....................    lcd_gotoxy(1,2);  
0BE7:  MOVLW  01
0BE8:  MOVWF  4C
0BE9:  MOVLW  02
0BEA:  MOVWF  4D
0BEB:  BCF    0A.3
0BEC:  CALL   1F5
0BED:  BSF    0A.3
....................    if (HsOff == 48 ) printf(lcd_putc,"Hs Apagad: OFF  ");  
0BEE:  MOVF   32,W
0BEF:  SUBLW  30
0BF0:  BTFSS  03.2
0BF1:  GOTO   3FB
0BF2:  MOVLW  4F
0BF3:  BSF    03.6
0BF4:  MOVWF  0D
0BF5:  MOVLW  00
0BF6:  MOVWF  0F
0BF7:  BCF    0A.3
0BF8:  BCF    03.6
0BF9:  CALL   22B
0BFA:  BSF    0A.3
....................    printf(lcd_putc,"Hs Apagad: %02d:%02d", HsOff/2,(HsOff%2)*30); 
0BFB:  BCF    03.0
0BFC:  RRF    32,W
0BFD:  MOVWF  3E
0BFE:  MOVF   32,W
0BFF:  ANDLW  01
0C00:  MOVWF  40
0C01:  MOVWF  41
0C02:  MOVLW  1E
0C03:  MOVWF  42
0C04:  BCF    0A.3
0C05:  CALL   7B5
0C06:  BSF    0A.3
0C07:  MOVF   78,W
0C08:  MOVWF  3F
0C09:  MOVLW  58
0C0A:  BSF    03.6
0C0B:  MOVWF  0D
0C0C:  MOVLW  00
0C0D:  MOVWF  0F
0C0E:  BCF    03.0
0C0F:  MOVLW  0B
0C10:  BCF    03.6
0C11:  MOVWF  40
0C12:  CALL   1C2
0C13:  MOVF   3E,W
0C14:  MOVWF  40
0C15:  MOVLW  01
0C16:  MOVWF  41
0C17:  CALL   15F
0C18:  MOVLW  3A
0C19:  MOVWF  4B
0C1A:  BCF    0A.3
0C1B:  CALL   207
0C1C:  BSF    0A.3
0C1D:  MOVF   3F,W
0C1E:  MOVWF  40
0C1F:  MOVLW  01
0C20:  MOVWF  41
0C21:  CALL   15F
....................    break; 
0C22:  GOTO   48F
....................  
....................    case 2: 
....................    lcd_gotoxy(1,2);  
0C23:  MOVLW  01
0C24:  MOVWF  4C
0C25:  MOVLW  02
0C26:  MOVWF  4D
0C27:  BCF    0A.3
0C28:  CALL   1F5
0C29:  BSF    0A.3
....................    printf(lcd_putc,"Limite Pot: %d kW", (MaxPower * 2));  
0C2A:  BCF    03.0
0C2B:  RLF    33,W
0C2C:  MOVWF  3E
0C2D:  MOVLW  63
0C2E:  BSF    03.6
0C2F:  MOVWF  0D
0C30:  MOVLW  00
0C31:  MOVWF  0F
0C32:  BCF    03.0
0C33:  MOVLW  0C
0C34:  BCF    03.6
0C35:  MOVWF  40
0C36:  CALL   1C2
0C37:  MOVF   3E,W
0C38:  MOVWF  40
0C39:  MOVLW  18
0C3A:  MOVWF  41
0C3B:  CALL   21A
0C3C:  MOVLW  20
0C3D:  MOVWF  4B
0C3E:  BCF    0A.3
0C3F:  CALL   207
0C40:  BSF    0A.3
0C41:  MOVLW  6B
0C42:  MOVWF  4B
0C43:  BCF    0A.3
0C44:  CALL   207
0C45:  BSF    0A.3
0C46:  MOVLW  57
0C47:  MOVWF  4B
0C48:  BCF    0A.3
0C49:  CALL   207
0C4A:  BSF    0A.3
....................    break; 
0C4B:  GOTO   48F
....................  
....................    case 1: 
....................    lcd_gotoxy(1,2);  
0C4C:  MOVLW  01
0C4D:  MOVWF  4C
0C4E:  MOVLW  02
0C4F:  MOVWF  4D
0C50:  BCF    0A.3
0C51:  CALL   1F5
0C52:  BSF    0A.3
....................    printf(lcd_putc,"Ar: Bba Ab: Valv");  
0C53:  MOVLW  6C
0C54:  BSF    03.6
0C55:  MOVWF  0D
0C56:  MOVLW  00
0C57:  MOVWF  0F
0C58:  BCF    0A.3
0C59:  BCF    03.6
0C5A:  CALL   22B
0C5B:  BSF    0A.3
....................    break; 
0C5C:  GOTO   48F
....................  
....................    case 6: 
....................    lcd_gotoxy(1,2);  
0C5D:  MOVLW  01
0C5E:  MOVWF  4C
0C5F:  MOVLW  02
0C60:  MOVWF  4D
0C61:  BCF    0A.3
0C62:  CALL   1F5
0C63:  BSF    0A.3
....................    printf(lcd_putc,"Ajuste de Hora  ");  
0C64:  MOVLW  75
0C65:  BSF    03.6
0C66:  MOVWF  0D
0C67:  MOVLW  00
0C68:  MOVWF  0F
0C69:  BCF    0A.3
0C6A:  BCF    03.6
0C6B:  CALL   22B
0C6C:  BSF    0A.3
....................    break; 
0C6D:  GOTO   48F
....................  
....................    case 7: 
....................    lcd_gotoxy(1,2);  
0C6E:  MOVLW  01
0C6F:  MOVWF  4C
0C70:  MOVLW  02
0C71:  MOVWF  4D
0C72:  BCF    0A.3
0C73:  CALL   1F5
0C74:  BSF    0A.3
....................    printf(lcd_putc,"Ajuste de Hora  ");  
0C75:  MOVLW  7E
0C76:  BSF    03.6
0C77:  MOVWF  0D
0C78:  MOVLW  00
0C79:  MOVWF  0F
0C7A:  BCF    0A.3
0C7B:  BCF    03.6
0C7C:  CALL   22B
0C7D:  BSF    0A.3
....................    break; 
0C7E:  GOTO   48F
....................  
....................    case 8: 
....................    lcd_gotoxy(1,2);  
0C7F:  MOVLW  01
0C80:  MOVWF  4C
0C81:  MOVLW  02
0C82:  MOVWF  4D
0C83:  BCF    0A.3
0C84:  CALL   1F5
0C85:  BSF    0A.3
....................    printf(lcd_putc,"Ajuste de Minuto");  
0C86:  MOVLW  87
0C87:  BSF    03.6
0C88:  MOVWF  0D
0C89:  MOVLW  00
0C8A:  MOVWF  0F
0C8B:  BCF    0A.3
0C8C:  BCF    03.6
0C8D:  CALL   22B
0C8E:  BSF    0A.3
....................    break; 
.................... } //SW 
.................... } //FN 
0C8F:  RETURN
....................  
.................... void Calefa(){ 
.................... int diferencia; 
.................... int PromTemp; 
.................... PromTemp = ((intTempOut + intTempIn) / 2); 
*
0F39:  MOVF   2E,W
0F3A:  ADDWF  2F,W
0F3B:  MOVWF  77
0F3C:  BCF    03.0
0F3D:  RRF    77,W
0F3E:  MOVWF  3F
.................... if (Menu == 3){ // Funcionando 
0F3F:  MOVF   25,W
0F40:  SUBLW  03
0F41:  BTFSS  03.2
0F42:  GOTO   7C1
.................... restart_wdt(); // Reiniciamos el perro 
0F43:  CLRWDT
.................... if (Termostato == 7) Apagado(); 
0F44:  MOVF   30,W
0F45:  SUBLW  07
0F46:  BTFSS  03.2
0F47:  GOTO   762
.................... else{ 
*
0F61:  GOTO   7C0
.................... output_high(BBA); 
0F62:  BSF    03.5
0F63:  BCF    08.1
0F64:  BCF    03.5
0F65:  BSF    08.1
.................... if (PromTemp >= (Termostato * 5)) SaleCalor(0); 
0F66:  MOVF   30,W
0F67:  MOVWF  41
0F68:  MOVLW  05
0F69:  MOVWF  42
0F6A:  BCF    0A.3
0F6B:  CALL   7B5
0F6C:  BSF    0A.3
0F6D:  MOVF   78,W
0F6E:  SUBWF  3F,W
0F6F:  BTFSS  03.0
0F70:  GOTO   776
0F71:  CLRF   40
0F72:  BCF    0A.3
0F73:  CALL   276
0F74:  BSF    0A.3
.................... else { //Termostato en aumento 
0F75:  GOTO   7C0
.................... diferencia = ((Termostato * 5) - PromTemp); 
0F76:  MOVF   30,W
0F77:  MOVWF  41
0F78:  MOVLW  05
0F79:  MOVWF  42
0F7A:  BCF    0A.3
0F7B:  CALL   7B5
0F7C:  BSF    0A.3
0F7D:  MOVF   3F,W
0F7E:  SUBWF  78,W
0F7F:  MOVWF  3E
.................... if (diferencia == 1) SaleCalor(1); 
0F80:  DECFSZ 3E,W
0F81:  GOTO   787
0F82:  MOVLW  01
0F83:  MOVWF  40
0F84:  BCF    0A.3
0F85:  CALL   276
0F86:  BSF    0A.3
.................... if (diferencia == 2) if (MaxPower >= 2) SaleCalor(2); else SaleCalor(MaxPower); 
0F87:  MOVF   3E,W
0F88:  SUBLW  02
0F89:  BTFSS  03.2
0F8A:  GOTO   79A
0F8B:  MOVF   33,W
0F8C:  SUBLW  01
0F8D:  BTFSC  03.0
0F8E:  GOTO   795
0F8F:  MOVLW  02
0F90:  MOVWF  40
0F91:  BCF    0A.3
0F92:  CALL   276
0F93:  BSF    0A.3
0F94:  GOTO   79A
0F95:  MOVF   33,W
0F96:  MOVWF  40
0F97:  BCF    0A.3
0F98:  CALL   276
0F99:  BSF    0A.3
.................... if (diferencia == 3) if (MaxPower >= 3) SaleCalor(3); else SaleCalor(MaxPower); 
0F9A:  MOVF   3E,W
0F9B:  SUBLW  03
0F9C:  BTFSS  03.2
0F9D:  GOTO   7AD
0F9E:  MOVF   33,W
0F9F:  SUBLW  02
0FA0:  BTFSC  03.0
0FA1:  GOTO   7A8
0FA2:  MOVLW  03
0FA3:  MOVWF  40
0FA4:  BCF    0A.3
0FA5:  CALL   276
0FA6:  BSF    0A.3
0FA7:  GOTO   7AD
0FA8:  MOVF   33,W
0FA9:  MOVWF  40
0FAA:  BCF    0A.3
0FAB:  CALL   276
0FAC:  BSF    0A.3
.................... if (diferencia >= 4) if (MaxPower >= 4) SaleCalor(4); else SaleCalor(MaxPower); 
0FAD:  MOVF   3E,W
0FAE:  SUBLW  03
0FAF:  BTFSC  03.0
0FB0:  GOTO   7C0
0FB1:  MOVF   33,W
0FB2:  SUBLW  03
0FB3:  BTFSC  03.0
0FB4:  GOTO   7BB
0FB5:  MOVLW  04
0FB6:  MOVWF  40
0FB7:  BCF    0A.3
0FB8:  CALL   276
0FB9:  BSF    0A.3
0FBA:  GOTO   7C0
0FBB:  MOVF   33,W
0FBC:  MOVWF  40
0FBD:  BCF    0A.3
0FBE:  CALL   276
0FBF:  BSF    0A.3
.................... /* 
.................... if (diferencia < 2 ) SaleCalor(1); 
.................... if ((diferencia >= 2 ) && (diferencia < 4)) if (MaxPower >= 2) SaleCalor(2); else SaleCalor(MaxPower); 
.................... if ((diferencia >= 4) && (diferencia < 5)) if (MaxPower >= 3) SaleCalor(3); else SaleCalor(MaxPower); 
.................... if ((diferencia >= 5) && (diferencia < 6)) if (MaxPower >= 4) SaleCalor(4); else SaleCalor(MaxPower); 
.................... if ((diferencia >= 6) && (diferencia < 7)) if (MaxPower >= 5) SaleCalor(5); else SaleCalor(MaxPower); 
.................... if ((diferencia >= 7) && (diferencia < 8)) if (MaxPower >= 6) SaleCalor(6); else SaleCalor(MaxPower); 
.................... if ((diferencia >= 8) && (diferencia < 9)) if (MaxPower >= 7) SaleCalor(7); else SaleCalor(MaxPower); 
.................... if ( diferencia >= 9) if (MaxPower >= 8) SaleCalor(8); else SaleCalor(MaxPower); 
.................... */ 
.................... } // Termostato en aumento 
.................... } 
.................... } else ShutDown(); // Menu es 2 o sea operacion normal 
0FC0:  GOTO   7C2
0FC1:  CALL   6DD
.................... } // Fn 
....................  
.................... void Automa(){ 
.................... if (((HsOn / 2) == hrs) && (((HsOn % 2) * 30) == min)){ 
*
0E29:  BCF    03.0
0E2A:  RRF    31,W
0E2B:  SUBWF  23,W
0E2C:  BTFSS  03.2
0E2D:  GOTO   63D
0E2E:  MOVF   31,W
0E2F:  ANDLW  01
0E30:  MOVWF  3F
0E31:  MOVWF  41
0E32:  MOVLW  1E
0E33:  MOVWF  42
0E34:  BCF    0A.3
0E35:  CALL   7B5
0E36:  BSF    0A.3
0E37:  MOVF   22,W
0E38:  SUBWF  78,W
0E39:  BTFSS  03.2
0E3A:  GOTO   63D
.................... Menu = 3; 
0E3B:  MOVLW  03
0E3C:  MOVWF  25
.................... // EX DISEÑO if (Termostato == 7) Termostato = read_eeprom(TERMOSTAT); 
.................... // EX DISEÑO if (Termostato == 7) Termostato = 13; //por si estaba apagada 
.................... }//On conincide 
....................  
.................... if (((HsOff / 2) == hrs) && (((HsOff % 2) * 30) == min)){ 
0E3D:  BCF    03.0
0E3E:  RRF    32,W
0E3F:  SUBWF  23,W
0E40:  BTFSS  03.2
0E41:  GOTO   651
0E42:  MOVF   32,W
0E43:  ANDLW  01
0E44:  MOVWF  3F
0E45:  MOVWF  41
0E46:  MOVLW  1E
0E47:  MOVWF  42
0E48:  BCF    0A.3
0E49:  CALL   7B5
0E4A:  BSF    0A.3
0E4B:  MOVF   22,W
0E4C:  SUBWF  78,W
0E4D:  BTFSS  03.2
0E4E:  GOTO   651
.................... Menu = 2; 
0E4F:  MOVLW  02
0E50:  MOVWF  25
.................... // EX DISEÑO Termostato = 7; 
.................... }//Off conincide 
.................... }//fn 
0E51:  BCF    0A.3
0E52:  BSF    0A.4
0E53:  GOTO   275 (RETURN)
....................  
.................... void Criticos(){ 
.................... if ((intTempOut > 86) && (intTempOut <= 100)) ++CritExS1;  
*
0EF7:  MOVF   2F,W
0EF8:  SUBLW  56
0EF9:  BTFSC  03.0
0EFA:  GOTO   6FF
0EFB:  MOVF   2F,W
0EFC:  SUBLW  64
0EFD:  BTFSC  03.0
0EFE:  INCF   39,F
.................... if ((intTempIn  > 86) && (intTempIn  <= 100)) ++CritExS2;  
0EFF:  MOVF   2E,W
0F00:  SUBLW  56
0F01:  BTFSC  03.0
0F02:  GOTO   707
0F03:  MOVF   2E,W
0F04:  SUBLW  64
0F05:  BTFSC  03.0
0F06:  INCF   3A,F
.................... if ((CritExS1 > 2) || (CritExS2 > 2)) { ShutDown(); EstadoCritico = 1; } 
0F07:  MOVF   39,W
0F08:  SUBLW  02
0F09:  BTFSS  03.0
0F0A:  GOTO   70F
0F0B:  MOVF   3A,W
0F0C:  SUBLW  02
0F0D:  BTFSC  03.0
0F0E:  GOTO   712
0F0F:  CALL   6DD
0F10:  MOVLW  01
0F11:  MOVWF  37
....................  
.................... /*if (input(CRITICO) == 1) { //Evitamos falsas lecturas 
....................    delay_ms(500); 
....................    if (input(CRITICO) == 1) { 
....................       delay_ms(500); 
....................       if (input(CRITICO) == 1) { 
....................          ShutDown(); 
....................          EstadoCritico = 2; 
....................       } 
....................    } 
.................... } // Nivel critico */ 
....................  
.................... if (NCritico == True){ 
0F12:  BTFSS  24.2
0F13:  GOTO   717
....................    ShutDown(); 
0F14:  CALL   6DD
....................    EstadoCritico = 2; 
0F15:  MOVLW  02
0F16:  MOVWF  37
.................... } 
....................  
.................... if ((intTempOut > 100) || (intTempOut < 4)) ++CritErS1; 
0F17:  MOVF   2F,W
0F18:  SUBLW  64
0F19:  BTFSS  03.0
0F1A:  GOTO   71E
0F1B:  MOVF   2F,W
0F1C:  SUBLW  03
0F1D:  BTFSC  03.0
0F1E:  INCF   3B,F
.................... if ((intTempIn  > 100) || (intTempIn  < 4)) ++CritErS2;  
0F1F:  MOVF   2E,W
0F20:  SUBLW  64
0F21:  BTFSS  03.0
0F22:  GOTO   726
0F23:  MOVF   2E,W
0F24:  SUBLW  03
0F25:  BTFSC  03.0
0F26:  INCF   3C,F
.................... if ((CritErS1 > 2) || (CritErS2 > 2)) { ShutDown(); EstadoCritico = 3; } 
0F27:  MOVF   3B,W
0F28:  SUBLW  02
0F29:  BTFSS  03.0
0F2A:  GOTO   72F
0F2B:  MOVF   3C,W
0F2C:  SUBLW  02
0F2D:  BTFSC  03.0
0F2E:  GOTO   732
0F2F:  CALL   6DD
0F30:  MOVLW  03
0F31:  MOVWF  37
....................  
....................  
.................... if (EstadoCritico == 0){ 
0F32:  MOVF   37,F
0F33:  BTFSS  03.2
0F34:  GOTO   7C8
.................... if (Menu == 3){ 
0F35:  MOVF   25,W
0F36:  SUBLW  03
0F37:  BTFSS  03.2
0F38:  GOTO   7C7
.................... Calefa(); 
.................... output_high(BBA); 
*
0FC2:  BSF    03.5
0FC3:  BCF    08.1
0FC4:  BCF    03.5
0FC5:  BSF    08.1
.................... //if (input(LLENADO) == 1) Llenar = True; 
.................... //else Llenar = False; 
.................... } else ShutDown(); // Menu 1 
0FC6:  GOTO   7C8
0FC7:  CALL   6DD
.................... } //Estado Critico 0 
.................... } // fn 
0FC8:  BCF    0A.3
0FC9:  BSF    0A.4
0FCA:  GOTO   29E (RETURN)
....................  
.................... void ShutDown(){ 
.................... if ((intTempOut < 40) && (intTempIn < 40)) output_low(BBA); 
*
0EDD:  MOVF   2F,W
0EDE:  SUBLW  27
0EDF:  BTFSS  03.0
0EE0:  GOTO   6EA
0EE1:  MOVF   2E,W
0EE2:  SUBLW  27
0EE3:  BTFSS  03.0
0EE4:  GOTO   6EA
0EE5:  BSF    03.5
0EE6:  BCF    08.1
0EE7:  BCF    03.5
0EE8:  BCF    08.1
.................... else output_high(BBA); 
0EE9:  GOTO   6EE
0EEA:  BSF    03.5
0EEB:  BCF    08.1
0EEC:  BCF    03.5
0EED:  BSF    08.1
.................... output_low(VALVE); 
0EEE:  BSF    03.5
0EEF:  BCF    08.2
0EF0:  BCF    03.5
0EF1:  BCF    08.2
.................... SaleCalor(0); 
0EF2:  CLRF   40
0EF3:  BCF    0A.3
0EF4:  CALL   276
0EF5:  BSF    0A.3
.................... } 
0EF6:  RETURN
....................  
.................... void Apagado(){ 
.................... if ((intTempOut < 40) && (intTempIn < 40)) output_low(BBA); 
*
0F48:  MOVF   2F,W
0F49:  SUBLW  27
0F4A:  BTFSS  03.0
0F4B:  GOTO   755
0F4C:  MOVF   2E,W
0F4D:  SUBLW  27
0F4E:  BTFSS  03.0
0F4F:  GOTO   755
0F50:  BSF    03.5
0F51:  BCF    08.1
0F52:  BCF    03.5
0F53:  BCF    08.1
.................... else output_high(BBA); 
0F54:  GOTO   759
0F55:  BSF    03.5
0F56:  BCF    08.1
0F57:  BCF    03.5
0F58:  BSF    08.1
.................... output_low(VALVE); 
0F59:  BSF    03.5
0F5A:  BCF    08.2
0F5B:  BCF    03.5
0F5C:  BCF    08.2
.................... SaleCalor(0); 
0F5D:  CLRF   40
0F5E:  BCF    0A.3
0F5F:  CALL   276
0F60:  BSF    0A.3
.................... } 
....................  
....................  

Configuration Fuses:
   Word  1: 3F76   HS WDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
